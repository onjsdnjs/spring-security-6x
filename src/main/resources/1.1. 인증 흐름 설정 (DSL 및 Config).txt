1.1. 인증 흐름 설정 (DSL 및 Config)
코드 스니펫

classDiagram
    direction LR
    class PlatformSecurityConfig {
        +platformDslConfig(IdentityDslRegistry) PlatformConfig
        -singleAuthFailureHandler(String) AuthenticationFailureHandler
    }
    class IdentityDslRegistry {
        +global(SafeHttpCustomizer) IdentityAuthDsl
        +form(Customizer) IdentityStateDsl
        +rest(Customizer) IdentityStateDsl
        +ott(Customizer) IdentityStateDsl
        +passkey(Customizer) IdentityStateDsl
        +mfa(Customizer) IdentityStateDsl
        +build() PlatformConfig
    }
    class AbstractFlowRegistrar {
        #platformBuilder PlatformConfig.Builder
        #registerAuthenticationMethod(...) IdentityStateDsl
        #registerMultiStepFlow(...) IdentityStateDsl
    }
    class PlatformConfig {
        +getGlobalCustomizer() SafeHttpCustomizer
        +getFlows() List~AuthenticationFlowConfig~
    }
    class AuthenticationFlowConfig {
        +getTypeName() String
        +getOrder() int
        +getStateConfig() StateConfig
        +getStepConfigs() List~AuthenticationStepConfig~
        +getPrimaryAuthenticationOptions() PrimaryAuthenticationOptions
        +getMfaPolicyProvider() MfaPolicyProvider
        +getFinalSuccessHandler() AuthenticationSuccessHandler
        +getMfaAsepAttributes() MfaAsepAttributes
    }
    class AuthenticationStepConfig {
        +getStepId() String
        +getType() String
        +getOrder() int
        +getOptions() Map
    }
    class AbstractOptions {
        +applyCommonSecurityConfigs(HttpSecurity) void
    }
    class AuthenticationProcessingOptions {
        +getLoginProcessingUrl() String
        +getSuccessHandler() AuthenticationSuccessHandler
        +getFailureHandler() AuthenticationFailureHandler
    }
    FormOptions --|> AuthenticationProcessingOptions
    RestOptions --|> AuthenticationProcessingOptions
    OttOptions --|> AuthenticationProcessingOptions
    PasskeyOptions --|> AuthenticationProcessingOptions
    PrimaryAuthenticationOptions ..> FormOptions : uses (optional)
    PrimaryAuthenticationOptions ..> RestOptions : uses (optional)

    PlatformSecurityConfig --> IdentityDslRegistry : uses
    IdentityDslRegistry --|> AbstractFlowRegistrar
    AbstractFlowRegistrar o-- PlatformConfig.Builder
    PlatformConfig o-- AuthenticationFlowConfig
    AuthenticationFlowConfig o-- AuthenticationStepConfig
    AuthenticationFlowConfig o-- StateConfig
    AuthenticationFlowConfig o-- PrimaryAuthenticationOptions
    AuthenticationStepConfig o-- AuthenticationProcessingOptions
    AuthenticationProcessingOptions --|> AbstractOptions

    note for PlatformSecurityConfig "최상위 Spring Security 설정 정의"
    note for IdentityDslRegistry "인증/상태 DSL 진입점"
    note for PlatformConfig "플랫폼 전체 인증 흐름 설정"
    note for AuthenticationFlowConfig "개별 인증 흐름 (Form, MFA 등) 설정"
    note for AuthenticationStepConfig "인증 흐름 내 각 단계 설정"
    note for AbstractOptions "모든 인증 옵션의 공통 설정"
    note for AuthenticationProcessingOptions "실제 인증 처리가 있는 옵션"

1.2. MFA 핵심 로직 및 컨텍스트
코드 스니펫

classDiagram
    direction LR
    class MfaPolicyProvider {
        +evaluateMfaRequirementAndDetermineInitialStep(Authentication, FactorContext) void
        +determineNextFactorToProcess(FactorContext) void
        +getRetryPolicyForFactor(AuthType, FactorContext) RetryPolicy
        +isFactorAvailableForUser(String, AuthType, FactorContext) boolean
    }
    class DefaultMfaPolicyProvider {
        -userRepository UserRepository
        -applicationContext ApplicationContext
    }
    DefaultMfaPolicyProvider --|> MfaPolicyProvider

    class FactorContext {
        -mfaSessionId String
        -currentMfaState MfaState
        -primaryAuthentication Authentication
        -username String
        -completedFactors List~AuthenticationStepConfig~
        +changeState(MfaState) void
        +addCompletedFactor(AuthenticationStepConfig) void
        +isFactorCompleted(String) boolean
        +getCurrentProcessingFactor() AuthType
        +setCurrentProcessingFactor(AuthType) void
    }
    interface ContextPersistence {
        +contextLoad(HttpServletRequest) FactorContext
        +saveContext(FactorContext, HttpServletRequest) void
        +deleteContext(HttpServletRequest) void
    }
    class HttpSessionContextPersistence {
        +MFA_CONTEXT_SESSION_ATTRIBUTE_NAME String
    }
    HttpSessionContextPersistence --|> ContextPersistence

    class MfaContinuationFilter {
        -contextPersistence ContextPersistence
        -mfaPolicyProvider MfaPolicyProvider
        -authContextProperties AuthContextProperties
        #doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain) void
        -handleMfaInitiationRequest(...) void
        -handleSelectFactorPageRequest(...) void
    }
    class MfaStepFilterWrapper {
        -configuredFactorFilterProvider ConfiguredFactorFilterProvider
        -contextPersistence ContextPersistence
        #doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain) void
    }
    class ConfiguredFactorFilterProvider {
        +registerFilter(FactorIdentifier, Filter) void
        +getFilter(FactorIdentifier) Filter
    }
    class FactorIdentifier {
        -flowName String
        -stepId String
    }

    MfaContinuationFilter o-- ContextPersistence
    MfaContinuationFilter o-- MfaPolicyProvider
    MfaStepFilterWrapper o-- ConfiguredFactorFilterProvider
    MfaStepFilterWrapper o-- ContextPersistence
    ConfiguredFactorFilterProvider o-- FactorIdentifier

    note for MfaPolicyProvider "MFA 정책 결정 (필요 여부, 다음 단계)"
    note for FactorContext "MFA 진행 중 상태 및 데이터 저장"
    note for ContextPersistence "FactorContext 영속화"
    note for MfaContinuationFilter "MFA 흐름 제어 및 UI 라우팅"
    note for MfaStepFilterWrapper "실제 Factor 인증 필터로 위임"

1.3. Spring State Machine (SSM) - MFA 상태 관리
코드 스니펫

classDiagram
    direction LR
    class MfaStateMachineService {
        +initializeStateMachine(FactorContext, HttpServletRequest) void
        +sendEvent(MfaEvent, FactorContext, HttpServletRequest) boolean
        +getCurrentState(String) MfaState
        +releaseStateMachine(String) void
    }
    class MfaStateMachineServiceImpl {
        -stateMachineFactory MfaStateMachineFactory
        -stateMachinePersister StateMachinePersister
        -factorContextAdapter FactorContextStateAdapter
        -contextPersistence ContextPersistence
    }
    MfaStateMachineServiceImpl --|> MfaStateMachineService

    interface MfaStateMachineFactory {
        +createStateMachine(String) StateMachine
        +restoreStateMachine(String) StateMachine
    }
    class MfaStateMachineFactoryImpl {
        -stateMachineFactory SpringStateMachineFactory
        -stateMachinePersister StateMachinePersister
    }
    MfaStateMachineFactoryImpl --|> MfaStateMachineFactory

    interface StateMachinePersist {
        +write(StateMachineContext, String) void
        +read(String) StateMachineContext
    }
    class InMemoryStateMachinePersist {
    }
    InMemoryStateMachinePersist --|> StateMachinePersist
    class RedisStateMachinePersist {
        -redisTemplate RedisTemplate
    }
    RedisStateMachinePersist --|> StateMachinePersist

    interface FactorContextStateAdapter {
        +toStateMachineVariables(FactorContext) Map
        +updateFactorContext(StateMachine, FactorContext) void
    }
    class FactorContextStateAdapterImpl {
    }
    FactorContextStateAdapterImpl --|> FactorContextStateAdapter

    class MfaStateMachineConfiguration {
        +configure(StateMachineStateConfigurer) void
        +configure(StateMachineTransitionConfigurer) void
    }
    MfaStateMachineConfiguration o-- AbstractMfaStateAction : uses actions
    MfaStateMachineConfiguration o-- AbstractMfaStateGuard : uses guards

    abstract class AbstractMfaStateAction {
        #factorContextAdapter FactorContextStateAdapter
        #stateContextHelper StateContextHelper
        +execute(StateContext) void
        #doExecute(StateContext, FactorContext) void
    }
    InitializeMfaAction --|> AbstractMfaStateAction
    SelectFactorAction --|> AbstractMfaStateAction
    InitiateChallengeAction --|> AbstractMfaStateAction
    VerifyFactorAction --|> AbstractMfaStateAction
    CompleteMfaAction --|> AbstractMfaStateAction
    HandleFailureAction --|> AbstractMfaStateAction

    abstract class AbstractMfaStateGuard {
        #stateContextHelper StateContextHelper
        +evaluate(StateContext) boolean
        #doEvaluate(StateContext, FactorContext) boolean
    }
    AllFactorsCompletedGuard --|> AbstractMfaStateGuard
    RetryLimitGuard --|> AbstractMfaStateGuard
    FactorAvailabilityGuard --|> AbstractMfaStateGuard
    MfaPolicyGuard --|> AbstractMfaStateGuard

    class StateContextHelper {
       +extractFactorContext(StateContext) FactorContext
       +saveFactorContext(StateContext, FactorContext) void
    }

    MfaStateMachineServiceImpl o-- MfaStateMachineFactory
    MfaStateMachineServiceImpl o-- FactorContextStateAdapter
    MfaStateMachineServiceImpl o-- ContextPersistence
    MfaStateMachineFactoryImpl o-- StateMachinePersister
    StateMachinePersister o-- StateMachinePersist

    note for MfaStateMachineService "SSM 외부 인터페이스"
    note for MfaStateMachineFactory "SSM 인스턴스 생성/복원"
    note for StateMachinePersist "SSM 컨텍스트 영속화 전략"
    note for FactorContextStateAdapter "FactorContext와 SSM 변수 동기화"
    note for MfaStateMachineConfiguration "SSM 상태, 전이, 액션, 가드 정의"
    note for AbstractMfaStateAction "SSM 액션 추상 클래스"
    note for AbstractMfaStateGuard "SSM 가드 추상 클래스"

1.4. 인증 핸들러 (Success/Failure)
코드 스니펫

classDiagram
    direction LR
    interface AuthenticationSuccessHandler
    interface AuthenticationFailureHandler

    class UnifiedAuthenticationSuccessHandler {
        -contextPersistence ContextPersistence
        -mfaPolicyProvider MfaPolicyProvider
        -tokenService TokenService
        +onAuthenticationSuccess(HttpServletRequest, HttpServletResponse, Authentication) void
        -handleFinalAuthenticationSuccess(...) void
    }
    UnifiedAuthenticationSuccessHandler --|> AuthenticationSuccessHandler

    class UnifiedAuthenticationFailureHandler {
        -contextPersistence ContextPersistence
        -mfaPolicyProvider MfaPolicyProvider
        -responseWriter AuthResponseWriter
        +onAuthenticationFailure(HttpServletRequest, HttpServletResponse, AuthenticationException) void
    }
    UnifiedAuthenticationFailureHandler --|> AuthenticationFailureHandler

    class MfaFactorProcessingSuccessHandler {
        -contextPersistence ContextPersistence
        -mfaPolicyProvider MfaPolicyProvider
        -finalSuccessHandler UnifiedAuthenticationSuccessHandler
        +onAuthenticationSuccess(HttpServletRequest, HttpServletResponse, Authentication) void
    }
    MfaFactorProcessingSuccessHandler --|> AuthenticationSuccessHandler

    class OneTimeTokenCreationSuccessHandler {
        -contextPersistence ContextPersistence
        -authContextProperties AuthContextProperties
        +handle(HttpServletRequest, HttpServletResponse, OneTimeToken) void
    }
    OneTimeTokenCreationSuccessHandler --|> SpringOneTimeTokenGenerationSuccessHandler

    class TokenService {
        +createAccessToken(Authentication, String) String
        +createRefreshToken(Authentication, String) String
        +refresh(String) RefreshResult
        +prepareTokensForTransport(String, String) TokenTransportResult
    }
    class AuthResponseWriter {
        +writeSuccessResponse(HttpServletResponse, Object, int) void
        +writeErrorResponse(HttpServletResponse, int, String, String, String) void
    }

    UnifiedAuthenticationSuccessHandler o-- TokenService
    UnifiedAuthenticationSuccessHandler o-- AuthResponseWriter
    MfaFactorProcessingSuccessHandler o-- AuthResponseWriter
    UnifiedAuthenticationFailureHandler o-- AuthResponseWriter

    note for UnifiedAuthenticationSuccessHandler "1차 인증 성공 또는 MFA 최종 성공 처리"
    note for MfaFactorProcessingSuccessHandler "개별 MFA Factor 성공 처리"
    note for UnifiedAuthenticationFailureHandler "전반적인 인증 실패 처리 (1차, MFA 등)"

2. 시퀀스 다이어그램 및 플로우 다이어그램
주요 기능별 상호작용을 나타냅니다. 모든 세부 호출보다는 핵심 흐름에 집중합니다.
2.1. 1차 인증 (REST API) 및 MFA 시작 (SSM 통합)
코드 스니펫

sequenceDiagram
    actor User
    participant ClientJS
    participant RestController
    participant RestAuthFilter [[RestAuthenticationFilter]]
    participant AuthManager [[AuthenticationManager]]
    participant UserDetailsSvc [[CustomUserDetailsService]]
    participant SuccessHandler [[UnifiedAuthenticationSuccessHandler]]
    participant PolicyProvider [[MfaPolicyProvider]]
    participant FactorCtx [[FactorContext]]
    participant CtxPersistence [[ContextPersistence]]
    participant StateMachineSvc [[MfaStateMachineService]]
    participant StateMachine [[Spring State Machine]]
    participant TokenSvc [[TokenService]]
    participant RespWriter [[AuthResponseWriter]]

    User->>ClientJS: 1. 로그인 (ID/PW)
    ClientJS->>RestController: 2. POST /api/auth/login
    RestController->>RestAuthFilter: 3. attemptAuthentication()
    RestAuthFilter->>AuthManager: 4. authenticate(UsernamePasswordAuthToken)
    AuthManager->>UserDetailsSvc: 5. loadUserByUsername()
    UserDetailsSvc-->>AuthManager: 6. UserDetails 반환
    AuthManager-->>RestAuthFilter: 7. 인증된 Authentication 객체 반환
    RestAuthFilter->>CtxPersistence: 8. contextLoad() (기존 컨텍스트 확인 및 삭제)
    RestAuthFilter->>FactorCtx: 9. new FactorContext (PRIMARY_AUTHENTICATION_COMPLETED, "primary")
    RestAuthFilter->>CtxPersistence: 10. saveContext(factorCtx)
    RestAuthFilter->>SuccessHandler: 11. onAuthenticationSuccess(auth, factorCtx)
    SuccessHandler->>PolicyProvider: 12. evaluateMfaRequirementAndDetermineInitialStep(auth, factorCtx)
    PolicyProvider->>FactorCtx: 13. update: mfaRequired, flowTypeName="mfa", currentState 등 설정
    SuccessHandler->>CtxPersistence: 14. saveContext(factorCtx)
    alt MFA 불필요
        SuccessHandler->>StateMachineSvc: 15a. initializeStateMachine(factorCtx)
        StateMachineSvc->>StateMachine: 16a. 생성 및 PRIMARY_AUTH_SUCCESS 이벤트
        StateMachineSvc->>StateMachine: 17a. MFA_NOT_REQUIRED 이벤트
        StateMachineSvc->>FactorCtx: 18a. updateState(ALL_FACTORS_COMPLETED)
        SuccessHandler->>TokenSvc: 19a. createAccessToken(), createRefreshToken()
        SuccessHandler->>RespWriter: 20a. 토큰 응답 (200 OK)
        RespWriter-->>ClientJS: 21a. 최종 성공 (토큰)
    else MFA 필요 (팩터 선택으로)
        SuccessHandler->>StateMachineSvc: 15b. initializeStateMachine(factorCtx)
        StateMachineSvc->>StateMachine: 16b. 생성 및 PRIMARY_AUTH_SUCCESS 이벤트
        StateMachineSvc->>StateMachine: 17b. MFA_REQUIRED_SELECT_FACTOR 이벤트
        StateMachineSvc->>FactorCtx: 18b. updateState(AWAITING_FACTOR_SELECTION)
        SuccessHandler->>RespWriter: 19b. MFA 필요 응답 (SC_FORBIDDEN, selectFactorUrl)
        RespWriter-->>ClientJS: 20b. MFA 선택 페이지로 안내
    else MFA 필요 (특정 팩터로 바로 진행 - 예: OTT)
        SuccessHandler->>StateMachineSvc: 15c. initializeStateMachine(factorCtx)
        StateMachineSvc->>StateMachine: 16c. 생성 및 PRIMARY_AUTH_SUCCESS 이벤트
        StateMachineSvc->>StateMachine: 17c. MFA_REQUIRED_INITIATE_CHALLENGE 이벤트 (payload:OTT)
        StateMachineSvc->>FactorCtx: 18c. updateState(AWAITING_FACTOR_CHALLENGE_INITIATION)
        SuccessHandler->>RespWriter: 19c. MFA 필요 응답 (SC_OK, nextFactorType, nextStepUrl 등)
        RespWriter-->>ClientJS: 20c. OTT 코드 요청 페이지로 안내
    end

2.2. MFA - 인증 수단 선택 및 챌린지 시작 (SSM 통합)
코드 스니펫

sequenceDiagram
    actor User
    participant ClientJS
    participant LoginCtrl [[LoginController]]
    participant MfaApiCtrl [[MfaApiController]]
    participant MfaContFilter [[MfaContinuationFilter]]
    participant FactorCtx [[FactorContext]]
    participant CtxPersistence [[ContextPersistence]]
    participant StateMachineSvc [[MfaStateMachineService]]
    participant StateMachine [[Spring State Machine]]
    participant RespWriter [[AuthResponseWriter]]

    User->>ClientJS: 1. /mfa/select-factor 페이지 요청
    ClientJS->>LoginCtrl: 2. GET /mfa/select-factor
    LoginCtrl->>CtxPersistence: 3. contextLoad()
    LoginCtrl->>StateMachineSvc: 4. getCurrentState() (AWAITING_FACTOR_SELECTION 확인)
    LoginCtrl-->>ClientJS: 5. Factor 선택 UI 렌더링

    User->>ClientJS: 6. OTT Factor 선택
    ClientJS->>MfaApiCtrl: 7. POST /api/mfa/select-factor (factorType=OTT)
    MfaApiCtrl->>CtxPersistence: 8. contextLoad()
    MfaApiCtrl->>StateMachineSvc: 9. sendEvent(FACTOR_SELECTED, factorCtx, {selectedFactor:OTT})
    StateMachineSvc->>StateMachine: 10. FACTOR_SELECTED 이벤트 처리 (SelectFactorAction 실행)
    StateMachine->>FactorCtx: 11. update: currentProcessingFactor=OTT, currentState=FACTOR_SELECTED
    StateMachineSvc->>StateMachine: 12. (내부적으로) INITIATE_CHALLENGE 이벤트 발생
    StateMachine->>StateMachineSvc: 13. InitiateChallengeAction 실행
    StateMachineSvc->>FactorCtx: 14. update: currentState=FACTOR_CHALLENGE_INITIATED
    MfaApiCtrl->>CtxPersistence: 15. saveContext(factorCtx)
    MfaApiCtrl->>RespWriter: 16. 응답 (nextStepUrl=/mfa/ott/request-code-ui)
    RespWriter-->>ClientJS: 17. OTT 코드 요청 페이지로 이동

    User->>ClientJS: 18. /mfa/ott/request-code-ui 페이지 요청
    ClientJS->>LoginCtrl: 19. GET /mfa/ott/request-code-ui
    LoginCtrl->>CtxPersistence: 20. contextLoad()
    LoginCtrl->>StateMachineSvc: 21. getCurrentState() (AWAITING_FACTOR_CHALLENGE_INITIATION 등 확인)
    LoginCtrl-->>ClientJS: 22. 코드 요청 UI 렌더링

    User->>ClientJS: 23. "코드 발송" 클릭 (폼 제출)
    ClientJS->>MfaContFilter: 24. POST /mfa/ott/generate-code (TokenGeneratingUrl)
    MfaContFilter->>CtxPersistence: 25. contextLoad()
    MfaContFilter->>GenerateOttFilter : 26. (위임) EmailOneTimeTokenService.generateAndSendVerificationCode()
    GenerateOttFilter-->>MfaContFilter: 27. 코드 발송 결과 (성공/실패)
    alt 코드 발송 성공
        MfaContFilter->>StateMachineSvc: 28a. sendEvent(CHALLENGE_INITIATED_SUCCESSFULLY, factorCtx)
        StateMachineSvc->>StateMachine: 29a. 이벤트 처리
        StateMachineSvc->>FactorCtx: 30a. updateState(FACTOR_CHALLENGE_PRESENTED_AWAITING_VERIFICATION)
        MfaContFilter->>CtxPersistence: 31a. saveContext(factorCtx)
        MfaContFilter-->>ClientJS: 32a. Redirect to /mfa/challenge/ott
    else 코드 발송 실패
        MfaContFilter->>StateMachineSvc: 28b. sendEvent(CHALLENGE_INITIATION_FAILED, factorCtx)
        StateMachineSvc->>StateMachine: 29b. 이벤트 처리 (HandleFailureAction 실행)
        StateMachineSvc->>FactorCtx: 30b. updateState(MFA_FAILED_TERMINAL 또는 AWAITING_FACTOR_SELECTION 등)
        MfaContFilter->>CtxPersistence: 31b. saveContext(factorCtx)
        MfaContFilter-->>ClientJS: 32b. 에러 응답 또는 리다이렉트
    end

2.3. MFA - OTT 코드 검증 (SSM 통합)
코드 스니펫

sequenceDiagram
    actor User
    participant ClientJS
    participant LoginCtrl [[LoginController]]
    participant MfaStepWrapper [[MfaStepFilterWrapper]]
    participant OttAuthFilter [[AuthenticationFilter (OTT)]]
    participant EmailOttSvc [[EmailOneTimeTokenService]]
    participant FactorSuccessHandler [[MfaFactorProcessingSuccessHandler]]
    participant FactorFailureHandler [[UnifiedAuthenticationFailureHandler]]
    participant PolicyProvider [[MfaPolicyProvider]]
    participant FactorCtx [[FactorContext]]
    participant CtxPersistence [[ContextPersistence]]
    participant StateMachineSvc [[MfaStateMachineService]]
    participant StateMachine [[Spring State Machine]]
    participant TokenSvc [[TokenService]]
    participant RespWriter [[AuthResponseWriter]]

    User->>ClientJS: 1. /mfa/challenge/ott 페이지에서 코드 입력 후 제출
    ClientJS->>MfaStepWrapper: 2. POST /login/mfa-ott (token, username)
    MfaStepWrapper->>CtxPersistence: 3. contextLoad()
    MfaStepWrapper->>ConfiguredFactorFilterProvider: 4. getFilter(factorId)
    ConfiguredFactorFilterProvider-->>MfaStepWrapper: 5. OttAuthFilter 반환
    MfaStepWrapper->>OttAuthFilter: 6. doFilter() 위임
    OttAuthFilter->>EmailOttSvc: 7. consume(token)
    EmailOttSvc-->>OttAuthFilter: 8. 코드 검증 결과 (성공/실패)
    alt OTT 검증 성공
        OttAuthFilter->>FactorSuccessHandler: 9a. onAuthenticationSuccess(auth, factorCtx)
        FactorSuccessHandler->>CtxPersistence: 10a. contextLoad()
        FactorSuccessHandler->>FactorCtx: 11a. addCompletedFactor(), resetFailedAttempts()
        FactorSuccessHandler->>StateMachineSvc: 12a. sendEvent(FACTOR_VERIFIED_SUCCESS, factorCtx)
        StateMachineSvc->>StateMachine: 13a. FACTOR_VERIFIED_SUCCESS 이벤트 처리 (VerifyFactorAction 실행)
        StateMachine->>PolicyProvider: 14a. (Guard 통해) AllFactorsCompletedGuard.evaluate()
        alt 모든 Factor 완료
            StateMachineSvc->>StateMachine: 15aa. ALL_REQUIRED_FACTORS_COMPLETED 이벤트 처리
            StateMachineSvc->>StateMachine: 16aa. (내부적으로) ALL_FACTORS_VERIFIED_PROCEED_TO_TOKEN 이벤트 발생
            StateMachine->>StateMachineSvc: 17aa. CompleteMfaAction 실행
            StateMachineSvc->>FactorCtx: 18aa. updateState(MFA_SUCCESSFUL)
            FactorSuccessHandler->>UnifiedAuthenticationSuccessHandler: 19aa. (위임) onAuthenticationSuccess()
            UnifiedAuthenticationSuccessHandler->>TokenSvc: 20aa. 토큰 발급
            UnifiedAuthenticationSuccessHandler->>RespWriter: 21aa. 최종 성공 응답 (토큰)
            RespWriter-->>ClientJS: 22aa. 로그인 완료
        else 추가 Factor 필요
            StateMachineSvc->>FactorCtx: 15ab. updateState(AWAITING_FACTOR_SELECTION 또는 다음 Factor 챌린지)
            FactorSuccessHandler->>RespWriter: 16ab. 다음 단계 안내 응답 (selectFactorUrl 또는 nextFactorUrl)
            RespWriter-->>ClientJS: 17ab. 다음 MFA 단계로 이동
        end
        FactorSuccessHandler->>CtxPersistence: 18a. saveContext(factorCtx)
    else OTT 검증 실패
        OttAuthFilter->>FactorFailureHandler: 9b. onAuthenticationFailure(exception, factorCtx)
        FactorFailureHandler->>CtxPersistence: 10b. contextLoad()
        FactorFailureHandler->>FactorCtx: 11b. recordAttempt(), incrementAttemptCount()
        FactorFailureHandler->>PolicyProvider: 12b. getRetryPolicyForFactor()
        FactorFailureHandler->>StateMachineSvc: 13b. sendEvent(FACTOR_VERIFICATION_FAILED, factorCtx)
        StateMachineSvc->>StateMachine: 14b. FACTOR_VERIFICATION_FAILED 이벤트 처리 (HandleFailureAction 실행)
        alt 재시도 가능
            StateMachineSvc->>FactorCtx: 15ba. updateState(FACTOR_CHALLENGE_PRESENTED_AWAITING_VERIFICATION)
            FactorFailureHandler->>RespWriter: 16ba. 재시도 안내 응답 (SC_UNAUTHORIZED)
            RespWriter-->>ClientJS: 17ba. 코드 재입력 UI
        else 재시도 한계 초과
            StateMachineSvc->>FactorCtx: 15bb. updateState(MFA_RETRY_LIMIT_EXCEEDED)
            StateMachineSvc->>StateMachine: 16bb. MFA_RETRY_LIMIT_EXCEEDED 이벤트 처리
            StateMachineSvc->>FactorCtx: 17bb. updateState(MFA_FAILED_TERMINAL)
            FactorFailureHandler->>RespWriter: 18bb. MFA 최종 실패 응답 (SC_FORBIDDEN, loginFormUrl)
            RespWriter-->>ClientJS: 19bb. 로그인 페이지로 이동
        end
        FactorFailureHandler->>CtxPersistence: 16b. saveContext(factorCtx) (또는 실패 시 삭제)
    end

2.4. 플로우 다이어그램: 일반적인 MFA 인증 흐름 (SSM 통합)
코드 스니펫

graph TD
    A[1차 인증 시도 (ID/PW)] --> B{인증 성공?};
    B -- Yes --> C[FactorContext 생성 & SSM 초기화 (PRIMARY_AUTH_SUCCESS)];
    C --> D{MFA 정책 평가};
    D -- MFA 불필요 --> E[SSM: MFA_NOT_REQUIRED 이벤트];
    E --> F[SSM: ALL_FACTORS_COMPLETED 상태];
    F --> G[최종 토큰 발급 / 성공];
    D -- MFA 필요 --> H{사용 가능한 Factor 존재?};
    H -- No --> I[MFA 설정 필요 안내];
    H -- Yes --> J[SSM: MFA_REQUIRED_SELECT_FACTOR 이벤트];
    J --> K[SSM: AWAITING_FACTOR_SELECTION 상태];
    K --> L[사용자: 인증 수단 선택 UI];
    L -- OTT 선택 --> M[Controller: SSM에 FACTOR_SELECTED(OTT) 이벤트 전송];
    M --> N[SSM: FACTOR_SELECTED 상태 (SelectFactorAction)];
    N --> O[SSM: INITIATE_CHALLENGE 이벤트];
    O --> P[SSM: FACTOR_CHALLENGE_INITIATED 상태 (InitiateChallengeAction)];
    P --> Q[Filter: OTT 코드 발송 요청 처리];
    Q -- 성공 --> R[SSM: CHALLENGE_INITIATED_SUCCESSFULLY 이벤트];
    R --> S[SSM: FACTOR_CHALLENGE_PRESENTED_AWAITING_VERIFICATION 상태];
    S --> T[사용자: OTT 코드 입력 UI];
    T -- 코드 제출 --> U[Filter: OTT 코드 검증];
    U -- 검증 성공 --> V[SSM: FACTOR_VERIFIED_SUCCESS 이벤트 (VerifyFactorAction)];
    V --> W[SSM: FACTOR_VERIFICATION_COMPLETED 상태];
    W -- 모든 Factor 완료 (Guard) --> X[SSM: ALL_REQUIRED_FACTORS_COMPLETED 이벤트];
    X --> F;
    W -- 추가 Factor 필요 --> K;
    U -- 검증 실패 --> Y{재시도 가능? (Guard)};
    Y -- Yes --> Z[SSM: FACTOR_VERIFICATION_FAILED 이벤트 (HandleFailureAction)];
    Z --> S;
    Y -- No --> AA[SSM: RETRY_LIMIT_EXCEEDED 이벤트];
    AA --> BB[SSM: MFA_FAILED_TERMINAL 상태];
    BB --> CC[MFA 최종 실패 처리];
    L -- Passkey 선택 --> M_PK[Controller: SSM에 FACTOR_SELECTED(PASSKEY) 이벤트 전송];
    M_PK --> N_PK[SSM: FACTOR_SELECTED 상태 (SelectFactorAction)];
    N_PK --> O_PK[SSM: INITIATE_CHALLENGE 이벤트];
    O_PK --> P_PK[SSM: FACTOR_CHALLENGE_INITIATED 상태 (InitiateChallengeAction)];
    P_PK --> Q_PK[API: Passkey Assertion Options 요청 처리];
    Q_PK -- 성공 --> R_PK[SSM: CHALLENGE_INITIATED_SUCCESSFULLY 이벤트];
    R_PK --> S_PK[SSM: FACTOR_CHALLENGE_PRESENTED_AWAITING_VERIFICATION 상태];
    S_PK --> T_PK[사용자: Passkey 인증 UI];
    T_PK -- Assertion 제출 --> U_PK[Filter: Passkey Assertion 검증];
    U_PK -- 검증 성공 --> V;
    U_PK -- 검증 실패 --> Y;
    B -- No --> CC;
    Q -- 실패 --> BB_CH[SSM: CHALLENGE_INITIATION_FAILED 이벤트];
    BB_CH --> CC;
    Q_PK -- 실패 --> BB_CH;

