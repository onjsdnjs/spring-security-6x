// ===== Package: io.springsecurity.springsecurity6x.security.config =====

// ----- Class: PlatformSecurityConfig -----
public PlatformSecurityConfig(ApplicationContext applicationContext, AuthContextProperties authContextProperties, ObjectMapper objectMapper, AuthResponseWriter authResponseWriter, EmailOneTimeTokenService emailOneTimeTokenService, UnifiedAuthenticationSuccessHandler unifiedAuthenticationSuccessHandler, UnifiedAuthenticationFailureHandler unifiedAuthenticationFailureHandler, MfaFactorProcessingSuccessHandler mfaFactorProcessingSuccessHandler, OneTimeTokenCreationSuccessHandler oneTimeTokenCreationSuccessHandler);
private AuthenticationFailureHandler singleAuthFailureHandler(String failureUrl);
public PlatformConfig platformDslConfig(IdentityDslRegistry<HttpSecurity> registry) throws Exception;

// ----- Class: MySecurityConfig -----
public WebSecurityCustomizer webSecurityCustomizer();
public PasswordEncoder passwordEncoder();
public ModelMapper modelMapper();
public ObjectMapper objectMapper();

// ===== Package: io.springsecurity.springsecurity6x.security.config.redis =====

// ----- Class: DistributedCacheConfig -----
public RedisCacheManagerBuilderCustomizer redisCacheManagerBuilderCustomizer();

// ----- Class: DistributedLockService -----
public DistributedLockService(RedisTemplate<String, String> redisTemplate);
public String acquireLock(String resourceKey, Duration leaseTime);
public boolean releaseLock(String resourceKey, String lockValue);
public <T> T executeWithLock(String resourceKey, Duration leaseTime, Duration waitTime, LockableOperation<T> operation);
// Interface: LockableOperation
public T execute() throws Exception;

// ----- Class: DistributedSessionConfig -----
public RedisSerializer<Object> springSessionDefaultRedisSerializer();
public DistributedSessionConfig();

// ----- Class: RedisEventListener -----
public RedisEventListener(RedisMessageListenerContainer messageListenerContainer, ObjectMapper objectMapper);
public void init();
@Override
public void onMessage(Message message, byte[] pattern);
private void processEvent(String channel, Map<String, Object> event);
private void handleAuthenticationEvent(String eventType, String username, Map<String, Object> data);
private void handleMfaEvent(String eventType, String username, Map<String, Object> data);
private void handleSecurityEvent(String eventType, String username, Map<String, Object> data);

// ----- Class: RedisEventPublisher -----
public RedisEventPublisher(RedisTemplate<String, Object> redisTemplate, ObjectMapper objectMapper);
public void publishAuthenticationEvent(String eventType, String username, Map<String, Object> additionalData);
public void publishMfaEvent(String eventType, String sessionId, String username, Map<String, Object> additionalData);
public void publishSecurityEvent(String eventType, String username, String ipAddress, Map<String, Object> additionalData);
private Map<String, Object> createEvent(String category, String eventType, String username, Map<String, Object> data);
private void publishEvent(String topicName, Map<String, Object> event);
private String getServerId();

// ----- Class: RedisMessageListenerConfig -----
public RedisMessageListenerContainer redisMessageListenerContainer(RedisConnectionFactory connectionFactory);
public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory);
public ObjectMapper objectMapper();

// ===== Package: io.springsecurity.springsecurity6x.security.core.adapter =====

// ----- Interface: AuthenticationAdapter -----
public String getId();
public int getOrder();
public void apply(HttpSecurity http, List<AuthenticationStepConfig> steps, StateConfig state) throws Exception;

// ----- Interface: StateAdapter -----
public String getId();
public void apply(HttpSecurity http, PlatformContext ctx) throws Exception;

// ===== Package: io.springsecurity.springsecurity6x.security.core.adapter.auth =====

// ----- Class: AbstractAuthenticationAdapter -----
protected abstract void configureHttpSecurity(HttpSecurity http, O options, AuthenticationSuccessHandler successHandler, AuthenticationFailureHandler failureHandler) throws Exception;
protected void configureHttpSecurityForOtt(HttpSecurity http, OttOptions options, OneTimeTokenGenerationSuccessHandler ottSuccessHandler, AuthenticationSuccessHandler successHandler, AuthenticationFailureHandler failureHandler) throws Exception;
@Override
public void apply(HttpSecurity http, List<AuthenticationStepConfig> allStepsInCurrentFlow, StateConfig stateConfig) throws Exception;
protected AuthenticationSuccessHandler resolveSuccessHandler(O options, @Nullable AuthenticationFlowConfig currentFlow, AuthenticationStepConfig myStepConfig, @Nullable List<AuthenticationStepConfig> allSteps, ApplicationContext appContext);
protected AuthenticationFailureHandler resolveFailureHandler(O options, @Nullable AuthenticationFlowConfig currentFlow, AuthenticationStepConfig myStepConfig, @Nullable List<AuthenticationStepConfig> allSteps, ApplicationContext appContext);
protected AuthenticationSuccessHandler determineDefaultSuccessHandler(O options, @Nullable AuthenticationFlowConfig currentFlow, AuthenticationStepConfig myStepConfig, @Nullable List<AuthenticationStepConfig> allSteps, ApplicationContext appContext);
protected OneTimeTokenGenerationSuccessHandler determineDefaultOttGenerationSuccessHandler(O options, @Nullable AuthenticationFlowConfig currentFlow, AuthenticationStepConfig myStepConfig, @Nullable List<AuthenticationStepConfig> allSteps, ApplicationContext appContext);
protected AuthenticationFailureHandler createDefaultFailureHandler(O options, ApplicationContext appContext);
protected String determineDefaultFailureUrl(O options);

// ----- Class: FormAuthenticationAdapter -----
@Override
public String getId();
@Override
public int getOrder();
@Override
protected void configureHttpSecurity(HttpSecurity http, FormOptions opts, AuthenticationSuccessHandler successHandler, AuthenticationFailureHandler failureHandler) throws Exception;
@Override
protected String determineDefaultFailureUrl(FormOptions options);

// ----- Class: MfaAuthenticationAdapter -----
public MfaAuthenticationAdapter();
public MfaAuthenticationAdapter(ApplicationContext applicationContext);
@Override
public String getId();
@Override
public int getOrder();
@Override
public void apply(HttpSecurity http, List<AuthenticationStepConfig> allStepsInCurrentFlow, StateConfig stateConfig) throws Exception;

// ----- Class: OttAuthenticationAdapter -----
@Override
public String getId();
@Override
public int getOrder();
@Override
protected void configureHttpSecurity(HttpSecurity http, OttOptions options, AuthenticationSuccessHandler successHandler, AuthenticationFailureHandler failureHandler) throws Exception;
@Override
public void configureHttpSecurityForOtt(HttpSecurity http, OttOptions opts, OneTimeTokenGenerationSuccessHandler tokenGenerationSuccessHandler, AuthenticationSuccessHandler successHandler, AuthenticationFailureHandler failureHandler) throws Exception;
@Override
protected String determineDefaultFailureUrl(OttOptions options);

// ----- Class: PasskeyAuthenticationAdapter -----
@Override
public String getId();
@Override
public int getOrder();
@Override
protected void configureHttpSecurity(HttpSecurity http, PasskeyOptions opts, AuthenticationSuccessHandler successHandler, AuthenticationFailureHandler failureHandler) throws Exception;
@Override
protected String determineDefaultFailureUrl(PasskeyOptions options);

// ----- Class: RestAuthenticationAdapter -----
@Override
public String getId();
@Override
public int getOrder();
@Override
protected void configureHttpSecurity(HttpSecurity http, RestOptions opts, AuthenticationSuccessHandler successHandler, AuthenticationFailureHandler failureHandler) throws Exception;

// ===== Package: io.springsecurity.springsecurity6x.security.core.adapter.state.jwt =====

// ----- Class: JwtStateAdapter -----
@Override
public String getId();
@Override
public void apply(HttpSecurity http, PlatformContext platformCtx) throws Exception;

// ----- Class: JwtStateConfigurer -----
public JwtStateConfigurer();
@Override
public void init(HttpSecurity http) throws Exception;
@Override
public void configure(HttpSecurity http) throws Exception;

// ===== Package: io.springsecurity.springsecurity6x.security.core.adapter.state.oauth2 =====

// ----- Class: OAuth2StateAdapter -----
public OAuth2StateAdapter();
public OAuth2StateAdapter(OAuth2StateConfigurer configurer);
@Override
public String getId();
@Override
public void apply(HttpSecurity http, PlatformContext ctx) throws Exception;

// ----- Class: OAuth2StateConfigurer -----
public void init(HttpSecurity http);
@Override
public void configure(HttpSecurity http) throws Exception;

// ===== Package: io.springsecurity.springsecurity6x.security.core.adapter.state.oauth2.client =====

// ----- Class: OAuth2AccessToken -----
public OAuth2AccessToken(String tokenValue, Instant expiresAt);
public String tokenValue();
public boolean isExpired();

// ----- Class: OAuth2AccessTokenResponse -----
public OAuth2AccessTokenResponse();

// ----- Class: OAuth2ClientRequest -----
// (Record - no explicit methods other than accessors)

// ----- Class: OAuth2HttpClient -----
public OAuth2HttpClient();
public <T> T get(String uri, String bearerToken, Class<T> responseType);
public <T> T post(String uri, String formBody, Class<T> responseType);
public <T> T post(String uri, Object jsonBody, String bearerToken, Class<T> responseType);

// ----- Class: OAuth2IntrospectionResponse -----
// (Record - no explicit methods other than accessors)

// ----- Class: OAuth2ResourceClient -----
public OAuth2ResourceClient(OAuth2TokenProvider tokenProvider);
public String issueAccessToken(String username);
public boolean validateAccessToken(String accessToken);
public OAuth2IntrospectionResponse getUserInfo(String accessToken);
public <T> T get(String uri, Class<T> responseType);
public <T> T post(String uri, Object body, Class<T> responseType);

// ----- Class: OAuth2TokenProvider -----
public OAuth2TokenProvider(String tokenUri, OAuth2ClientRequest clientRequest);
public synchronized String getAccessToken();
private OAuth2AccessToken requestNewAccessToken();
public String getIntrospectUri();

// ===== Package: io.springsecurity.springsecurity6x.security.core.adapter.state.session =====

// ----- Class: SessionStateAdapter -----
@Override
public String getId();
@Override
public void apply(HttpSecurity http, PlatformContext ctx) throws Exception;

// ----- Class: SessionStateConfigurer -----
@Override
public void init(HttpSecurity http);
@Override
public void configure(HttpSecurity http) throws Exception;

// ===== Package: io.springsecurity.springsecurity6x.security.core.bootstrap =====

// ----- Class: ConfiguredFactorFilterProvider -----
public ConfiguredFactorFilterProvider();
public void registerFilter(FactorIdentifier factorIdentifier, Filter filterInstance);
@Nullable
public Filter getFilter(FactorIdentifier factorIdentifier);
public int getRegisteredFilterCount();

// ----- Class: DefaultSecurityConfigurerProvider -----
public DefaultSecurityConfigurerProvider(List<SecurityConfigurer> baseConfigurers, FeatureRegistry featureRegistry, ApplicationContext applicationContext);
@Override
public List<SecurityConfigurer> getGlobalConfigurers(PlatformContext platformContext, PlatformConfig platformConfig);
@Override
public List<SecurityConfigurer> getFlowSpecificConfigurers(PlatformContext platformContext, PlatformConfig platformConfig, HttpSecurity httpForScope);

// ----- Class: FeatureRegistry -----
public FeatureRegistry(ApplicationContext applicationContext);
public List<AuthenticationAdapter> getAuthFeaturesFor(List<AuthenticationFlowConfig> flows);
public List<StateAdapter> getStateFeaturesFor(List<AuthenticationFlowConfig> flows);
@Nullable
public AuthenticationAdapter getAuthenticationFeature(String featureId);

// ----- Class: MfaInfrastructureAutoConfiguration -----
public MfaInfrastructureAutoConfiguration(AuthContextProperties authContextProperties, TokenService tokenService, UserRepository userRepository);
@Bean
@ConditionalOnMissingBean
public ContextPersistence contextPersistence();
@Bean
@ConditionalOnMissingBean
public MfaPolicyProvider mfaPolicyProvider(ApplicationContext applicationContext);
@Bean
@ConditionalOnMissingBean
public UnifiedAuthenticationSuccessHandler unifiedAuthenticationSuccessHandler(ContextPersistence contextPersistence, AuthResponseWriter authResponseWriter, MfaPolicyProvider mfaPolicyProvider, ApplicationContext applicationContext);
@Bean
@ConditionalOnMissingBean
public UnifiedAuthenticationFailureHandler unifiedAuthenticationFailureHandler(MfaPolicyProvider mfaPolicyProvider, ContextPersistence contextPersistence, AuthResponseWriter authResponseWriter, AuthContextProperties properties);
@Bean
@ConditionalOnMissingBean
public MfaFactorProcessingSuccessHandler mfaFactorProcessingSuccessHandler(ContextPersistence contextPersistence, MfaPolicyProvider mfaPolicyProvider, AuthResponseWriter authResponseWriter, AuthContextProperties properties, ApplicationContext applicationContext, UnifiedAuthenticationSuccessHandler successHandler);
@Bean
@ConditionalOnMissingBean
public LogoutHandler jwtLogoutHandler(TokenService tokenService, AuthResponseWriter authResponseWriter);
@Bean
@ConditionalOnMissingBean
public AuthResponseWriter authResponseWriter(ObjectMapper objectMapper);

// ----- Class: PathMappingRegistry -----
public PathMappingRegistry(PlatformConfig config);
public Set<String> singleAuthPaths();
public Set<String> mfaEntryPaths();
public Map<String, String> mfaStepPaths();
public Map<String, String> mfaStepTargetUrls();

// ----- Class: PlatformBootstrap -----
public PlatformBootstrap(SecurityPlatform platform, PlatformConfig config, FeatureRegistry registry, DslValidatorService dslValidatorService);
@Override
public void afterPropertiesSet() throws Exception;

// ----- Class: PlatformContextInitializer -----
public PlatformContextInitializer(PlatformContext platformContext, SecretKey secretKey, AuthContextProperties authContextProperties, ObjectMapper objectMapper);
public void initializeSharedObjects();

// ----- Class: SecurityConfigurerOrchestrator -----
public SecurityConfigurerOrchestrator(SecurityConfigurerProvider configurerProvider);
public void applyConfigurations(List<FlowContext> flows, PlatformContext platformContext, PlatformConfig platformConfig) throws Exception;

// ----- Interface: SecurityConfigurerProvider -----
public List<SecurityConfigurer> getGlobalConfigurers(PlatformContext platformContext, PlatformConfig platformConfig);
public List<SecurityConfigurer> getFlowSpecificConfigurers(PlatformContext platformContext, PlatformConfig platformConfig, HttpSecurity httpForScope);

// ----- Class: SecurityFilterChainRegistrar -----
public SecurityFilterChainRegistrar(ConfiguredFactorFilterProvider configuredFactorFilterProvider, Map<String, Class<? extends Filter>> stepFilterClasses);
public void registerSecurityFilterChains(List<FlowContext> flows, ApplicationContext context);
private OrderedSecurityFilterChain buildAndRegisterFilters(FlowContext fc);

// ----- Interface: SecurityPlatform -----
public void prepareGlobal(PlatformConfig config, List<?> features);
public void initialize() throws Exception;

// ----- Class: SecurityPlatformConfiguration -----
@Bean
public PlatformContext platformContext(ApplicationContext ctx, ObjectProvider<HttpSecurity> provider);
@Bean
public FeatureRegistry featureRegistry(ApplicationContext applicationContext);
@Bean
public SecurityConfigurer flowConfigurer();
@Bean
public SecurityConfigurer globalConfigurer();
@Bean
public ConfiguredFactorFilterProvider factorFilterProvider();
@Bean
public SecurityFilterChainRegistrar securityFilterChainRegistrar(ConfiguredFactorFilterProvider factorFilterProvider);
@Bean public LoginProcessingUrlUniquenessValidator loginProcessingUrlUniquenessValidator();
@Bean public MfaFlowStructureValidator mfaFlowStructureValidator();
@Bean public RequiredPlatformOptionsValidator requiredPlatformOptionsValidator();
@Bean public FeatureAvailabilityValidator featureAvailabilityValidator(FeatureRegistry featureRegistry);
@Bean public CustomBeanDependencyValidator customBeanDependencyValidator(ApplicationContext applicationContext);
@Bean public DuplicateFlowTypeNameValidator duplicateMfaFlowValidator();
@Bean
@ConditionalOnMissingBean
public DslValidator dslValidator(ObjectProvider<List<Validator<PlatformConfig>>> platformConfigValidatorsProvider, ObjectProvider<List<Validator<List<AuthenticationFlowConfig>>>> flowListValidatorsProvider, ObjectProvider<List<Validator<AuthenticationFlowConfig>>> singleFlowValidatorsProvider, ObjectProvider<List<Validator<AuthenticationStepConfig>>> stepValidatorsProvider, ObjectProvider<List<Validator<List<FlowContext>>>> duplicatedFlowValidators);
@Bean
public DslValidatorService dslValidatorService(DslValidator dslValidator);
@Bean
public PlatformContextInitializer platformContextInitializer(PlatformContext platformContext, SecretKey secretKey, AuthContextProperties authContextProperties, ObjectMapper objectMapper);
@Bean
public FlowContextFactory flowContextFactory(FeatureRegistry featureRegistry, ApplicationContext applicationContext);
@Bean
public SecurityPlatform securityPlatform(PlatformContext context, List<SecurityConfigurer> allRegisteredConfigurers, FeatureRegistry featureRegistry, PlatformContextInitializer platformContextInitializer, SecurityFilterChainRegistrar securityFilterChainRegistrar, FlowContextFactory flowContextFactory, PlatformConfig platformConfig, ApplicationContext applicationContext);
@Bean
public PlatformBootstrap platformBootstrap(SecurityPlatform securityPlatform, PlatformConfig platformConfig, FeatureRegistry registry, DslValidatorService dslValidatorService);

// ----- Class: SecurityPlatformInitializer -----
public SecurityPlatformInitializer(PlatformContext context, PlatformConfig config, SecurityFilterChainRegistrar registrar, FlowContextFactory flowContextFactory, SecurityConfigurerOrchestrator securityConfigurerOrchestrator);
@Override
public void prepareGlobal(PlatformConfig config, List<?> features);
@Override
public void initialize() throws Exception;

// ----- Class: TokenServiceConfiguration -----
@Bean
@ConditionalOnMissingBean
public SecretKey jwtSecretKey(AuthContextProperties props);
@Bean
public JwtTokenParser jwtTokenParser(SecretKey secretKey);
@Bean
public JwtRefreshTokenStore jwtRefreshTokenStore(JwtTokenParser jwtTokenParser, AuthContextProperties props);
@Bean
public JwtTokenCreator jwtTokenCreator(SecretKey secretKey);
@Bean
public JwtTokenValidator jwtTokenValidator(JwtTokenParser jwtTokenParser, JwtRefreshTokenStore jwtRefreshTokenStore, AuthContextProperties props);
@Bean
public TokenService tokenService(JwtTokenValidator jwtTokenValidator, JwtTokenCreator jwtTokenCreator, JwtRefreshTokenStore jwtRefreshTokenStore, AuthContextProperties props, ObjectMapper objectMapper, SecretKey secretKey);

// ===== Package: io.springsecurity.springsecurity6x.security.core.bootstrap.configurer =====

// ----- Class: AuthFeatureConfigurerAdapter -----
public AuthFeatureConfigurerAdapter(AuthenticationAdapter feature);
@Override
public void init(PlatformContext ctx, PlatformConfig config);
@Override
public void configure(FlowContext fc) throws Exception;
@Override
public int getOrder();

// ----- Class: FlowConfigurer -----
@Override
public void init(PlatformContext ctx, PlatformConfig config);
@Override
public void configure(FlowContext ctx);
@Override
public int getOrder();

// ----- Class: GlobalConfigurer -----
@Override
public void init(PlatformContext ctx, PlatformConfig config);
@Override
public void configure(FlowContext ctx);
@Override
public int getOrder();

// ----- Interface: SecurityConfigurer -----
public void init(PlatformContext ctx, PlatformConfig config);
public void configure(FlowContext fc) throws Exception;
@Override
default int getOrder();

// ----- Class: StateFeatureConfigurerAdapter -----
public StateFeatureConfigurerAdapter(StateAdapter feature, PlatformContext ctx);
@Override
public void init(PlatformContext ctx, PlatformConfig config);
@Override
public void configure(FlowContext fc) throws Exception;
@Override
public int getOrder();

// ===== Package: io.springsecurity.springsecurity6x.security.core.config =====

// ----- Class: AuthenticationFlowConfig -----
private AuthenticationFlowConfig(Builder builder);
public AuthenticationFlowConfig withStateConfig(StateConfig newStateConfig);
public static Builder builder(String typeName);
public String getTypeName();
public int getOrder();
public StateConfig getStateConfig();
public Customizer<HttpSecurity> getRawHttpCustomizer();
public PrimaryAuthenticationOptions getPrimaryAuthenticationOptions();
public MfaPolicyProvider getMfaPolicyProvider();
public MfaContinuationHandler getMfaContinuationHandler();
public AuthenticationFailureHandler getMfaFailureHandler();
public AuthenticationSuccessHandler getFinalSuccessHandler();
public Map<AuthType, AuthenticationProcessingOptions> getRegisteredFactorOptions();
public RetryPolicy getDefaultRetryPolicy();
public AdaptiveConfig getDefaultAdaptiveConfig();
public boolean isDefaultDeviceTrustEnabled();
public MfaAsepAttributes getMfaAsepAttributes();
public List<AuthenticationStepConfig> getStepConfigs();
// Inner Class: Builder
public Builder(String typeName);
public Builder typeName(String typeName);
public Builder order(int order);
public Builder stateConfig(StateConfig stateConfig);
public Builder rawHttpCustomizer(Customizer<HttpSecurity> customizer);
public Builder stepConfigs(List<AuthenticationStepConfig> steps);
public Builder primaryAuthenticationOptions(PrimaryAuthenticationOptions opts);
public Builder registeredFactorOptions(Map<AuthType, AuthenticationProcessingOptions> options);
public Builder mfaPolicyProvider(MfaPolicyProvider provider);
public Builder mfaContinuationHandler(MfaContinuationHandler handler);
public Builder mfaFailureHandler(AuthenticationFailureHandler handler);
public Builder finalSuccessHandler(AuthenticationSuccessHandler handler);
public Builder defaultRetryPolicy(RetryPolicy policy);
public Builder defaultAdaptiveConfig(AdaptiveConfig config);
public Builder defaultDeviceTrustEnabled(boolean enabled);
public Builder mfaAsepAttributes(MfaAsepAttributes attributes);
public AuthenticationFlowConfig build();

// ----- Class: AuthenticationStepConfig -----
public AuthenticationStepConfig();
public AuthenticationStepConfig(String type, int order);
public AuthenticationStepConfig(String flowName, String type, int order);
public void addOption(String key, Object value);
public <T> T getOption(String key);
public static String generateId(String flowName, String factorType, int order);
public String getStepId();
public void setStepId(String stepId);
public String getType();
public void setType(String type);
public AuthType getAuthType();
public void setAuthType(AuthType authType);
public Map<String, Object> getOptions();
public int getOrder();
public void setOrder(int order);
public boolean isRequired();
public void setRequired(boolean required);
@Override
public boolean equals(Object o);
@Override
public int hashCode();
@Override
public String toString();

// ----- Class: PlatformConfig -----
private PlatformConfig(Builder builder);
public static Builder builder();
public SafeHttpCustomizer<HttpSecurity> getGlobalCustomizer();
public List<AuthenticationFlowConfig> getFlows();
public PlatformContext getPlatformContext();
public void setPlatformContext(PlatformContext platformContext);
// Inner Class: Builder
public Builder global(SafeHttpCustomizer<HttpSecurity> globalCustomizer);
public Builder addFlow(AuthenticationFlowConfig flow);
public List<AuthenticationFlowConfig> getModifiableFlows();
public Builder replaceLastFlow(AuthenticationFlowConfig flow);
public PlatformConfig build();

// ----- Class: StateConfig -----
// (Record - no explicit methods other than accessors and constructor)

// ===== Package: io.springsecurity.springsecurity6x.security.core.context =====

// ----- Class: DefaultPlatformContext -----
public DefaultPlatformContext(ApplicationContext applicationContext, ObjectProvider<HttpSecurity> httpProvider);
@Override
public void addAuthConfig(AuthenticationStepConfig config);
@Override
public List<AuthenticationStepConfig> getAuthConfigs();
@Override
public <T> void share(Class<T> clz, T obj);
@Override
public <T> T getShared(Class<T> clz);
@Override
public void registerHttp(AuthenticationFlowConfig flow, HttpSecurity http);
@Override
public HttpSecurity http(AuthenticationFlowConfig flow);
public List<FlowContext> flowContexts();
public void flowContexts(List<FlowContext> flowContexts);
@Override
public HttpSecurity newHttp();
@Override
public void registerChain(String id, SecurityFilterChain chain);
@Override
public Map<String, SecurityFilterChain> getChains();
@Override
public ApplicationContext applicationContext();

// ----- Class: FlowContext -----
// (Record - no explicit methods other than accessors and constructor)

// ----- Class: FlowContextFactory -----
public FlowContextFactory(FeatureRegistry featureRegistry, ApplicationContext applicationContext);
public List<FlowContext> createAndSortFlows(PlatformConfig config, PlatformContext platformContext);
private void setupSharedObjectsForFlow(FlowContext fc);
private <T> void setSharedObjectIfAbsent(HttpSecurity http, Class<T> type, Supplier<T> supplier);

// ----- Class: OrderedSecurityFilterChain -----
public OrderedSecurityFilterChain(int order, RequestMatcher matcher, List<Filter> filters);
@Override
public int getOrder();
@Override
public boolean matches(HttpServletRequest request);
@Override
public List<Filter> getFilters();

// ----- Interface: PlatformContext -----
public void addAuthConfig(AuthenticationStepConfig config);
public List<AuthenticationStepConfig> getAuthConfigs();
public <T> void share(Class<T> clz, T obj);
public <T> T getShared(Class<T> clz);
public void registerHttp(AuthenticationFlowConfig flow, HttpSecurity http);
public HttpSecurity http(AuthenticationFlowConfig flow);
public List<FlowContext> flowContexts();
public void flowContexts(List<FlowContext> flowContexts);
public HttpSecurity newHttp();
public void registerChain(String id, SecurityFilterChain chain);
public Map<String, SecurityFilterChain> getChains();
public ApplicationContext applicationContext();

// ===== Package: io.springsecurity.springsecurity6x.security.core.dsl =====

// ----- Class: AbstractDslConfigurer -----
protected AbstractDslConfigurer(O options);
protected AbstractDslConfigurer(@Nullable AuthenticationStepConfig stepConfig, O options);
@Nullable
public AuthenticationStepConfig getStepConfig();
@Override
public D disableCsrf();
@Override
public D cors(Customizer<CorsConfigurer<HttpSecurity>> customizer);
@Override
public D headers(Customizer<HeadersConfigurer<HttpSecurity>> customizer);
@Override
public D sessionManagement(Customizer<SessionManagementConfigurer<HttpSecurity>> customizer);
@Override
public D logout(Customizer<LogoutConfigurer<HttpSecurity>> customizer);

// ----- Class: AbstractFlowRegistrar -----
protected AbstractFlowRegistrar(PlatformConfig.Builder platformBuilder, ApplicationContext applicationContext);
protected <O extends AuthenticationProcessingOptions, A extends BaseAsepAttributes, S extends AuthenticationFactorConfigurer<O, A, S>> IdentityStateDsl registerAuthenticationMethod(AuthType authType, Customizer<S> configurerCustomizer, int defaultOrder, Class<S> configurerInterfaceType);
protected IdentityStateDsl registerMultiStepFlow(Customizer<MfaDslConfigurer> customizer);

// ----- Interface: CommonSecurityDsl -----
public S disableCsrf();
public S cors(Customizer<CorsConfigurer<HttpSecurity>> customizer);
public S headers(Customizer<HeadersConfigurer<HttpSecurity>> customizer);
public S sessionManagement(Customizer<SessionManagementConfigurer<HttpSecurity>> customizer);
public S logout(Customizer<LogoutConfigurer<HttpSecurity>> customizer);

// ----- Class: DefaultRiskEngine -----
@Override
public RiskAssessmentResult assess(HttpServletRequest request);
private String extractClientIp(HttpServletRequest request);

// ----- Interface: IdentityAuthDsl -----
public IdentityAuthDsl global(SafeHttpCustomizer<HttpSecurity> customizer);
public IdentityStateDsl form(Customizer<FormDslConfigurer> customizer) throws Exception;
public IdentityStateDsl rest(Customizer<RestDslConfigurer> customizer) throws Exception;
public IdentityStateDsl ott(Customizer<OttDslConfigurer> customizer) throws Exception;
public IdentityStateDsl passkey(Customizer<PasskeyDslConfigurer> customizer) throws Exception;
public IdentityStateDsl mfa(Customizer<MfaDslConfigurer> customizer) throws Exception;
public PlatformConfig build();

// ----- Class: IdentityDslRegistry -----
public IdentityDslRegistry(ApplicationContext applicationContext);
@Override
public IdentityAuthDsl global(SafeHttpCustomizer<HttpSecurity> customizer);
@Override
public IdentityStateDsl form(Customizer<FormDslConfigurer> customizer) throws Exception;
@Override
public IdentityStateDsl rest(Customizer<RestDslConfigurer> customizer) throws Exception;
@Override
public IdentityStateDsl ott(Customizer<OttDslConfigurer> customizer) throws Exception;
@Override
public IdentityStateDsl passkey(Customizer<PasskeyDslConfigurer> customizer) throws Exception;
@Override
public IdentityStateDsl mfa(Customizer<MfaDslConfigurer> customizer) throws Exception;
@Override
public PlatformConfig build();

// ----- Interface: IdentityStateDsl -----
public IdentityAuthDsl session(Customizer<SessionStateConfigurer> customizer);
public IdentityAuthDsl jwt(Customizer<JwtStateConfigurer> customizer);
public IdentityAuthDsl oauth2(Customizer<OAuth2StateConfigurer> customizer);

// ===== Package: io.springsecurity.springsecurity6x.security.core.dsl.configurer =====

// ----- Interface: AuthenticationFactorConfigurer -----
public S order(int order);
public S asep(Customizer<A> asepAttributesCustomizer);

// ----- Interface: FormDslConfigurer -----
public FormDslConfigurer loginPage(String loginPageUrl);
public FormDslConfigurer usernameParameter(String usernameParameter);
public FormDslConfigurer passwordParameter(String passwordParameter);
public FormDslConfigurer defaultSuccessUrl(String defaultSuccessUrl, boolean alwaysUse);
public FormDslConfigurer failureUrl(String failureUrl);
public FormDslConfigurer permitAll();
public FormDslConfigurer rawFormLogin(SafeHttpFormLoginCustomizer customizer);

// ----- Interface: MfaDslConfigurer -----
public MfaDslConfigurer order(int order);
public MfaDslConfigurer form(Customizer<FormDslConfigurer> formConfigurer);
public MfaDslConfigurer rest(Customizer<RestDslConfigurer> restConfigurer);
public MfaDslConfigurer ott(Customizer<OttDslConfigurer> ottConfigurer);
public MfaDslConfigurer passkey(Customizer<PasskeyDslConfigurer> passkeyConfigurer);
public MfaDslConfigurer recoveryFlow(Customizer<RecoveryCodeDslConfigurer> recoveryConfigurerCustomizer);
public MfaDslConfigurer mfaContinuationHandler(MfaContinuationHandler continuationHandler);
public MfaDslConfigurer mfaFailureHandler(AuthenticationFailureHandler failureHandler);
public MfaDslConfigurer finalSuccessHandler(AuthenticationSuccessHandler handler);
public MfaDslConfigurer policyProvider(MfaPolicyProvider policyProvider);
public MfaDslConfigurer defaultRetryPolicy(Customizer<RetryPolicyDslConfigurer> c);
public MfaDslConfigurer defaultAdaptivePolicy(Customizer<AdaptiveDslConfigurer> c);
public MfaDslConfigurer defaultDeviceTrustEnabled(boolean enable);
public AuthenticationFlowConfig build();
public MfaDslConfigurer asep(Customizer<MfaAsepAttributes> mfaAsepAttributesCustomizer);
public MfaDslConfigurer primaryAuthentication(Customizer<PrimaryAuthDslConfigurer> primaryAuthConfig);

// ----- Interface: OttDslConfigurer -----
public OttDslConfigurer defaultSubmitPageUrl(String url);
public OttDslConfigurer tokenGeneratingUrl(String url);
public OttDslConfigurer showDefaultSubmitPage(boolean show);
public OttDslConfigurer tokenService(OneTimeTokenService service);
public OttDslConfigurer tokenGenerationSuccessHandler(OneTimeTokenGenerationSuccessHandler handler);

// ----- Interface: PasskeyDslConfigurer -----
public PasskeyDslConfigurer assertionOptionsEndpoint(String url);
public PasskeyDslConfigurer rpName(String rpName);
public PasskeyDslConfigurer rpId(String rpId);
public PasskeyDslConfigurer allowedOrigins(List<String> origins);
public PasskeyDslConfigurer allowedOrigins(String... origins);
public PasskeyDslConfigurer allowedOrigins(Set<String> origins);

// ----- Interface: PrimaryAuthDslConfigurer -----
public PrimaryAuthDslConfigurer formLogin(Customizer<FormDslConfigurer> formLoginCustomizer);
public PrimaryAuthDslConfigurer restLogin(Customizer<RestDslConfigurer> restLoginCustomizer);
public PrimaryAuthenticationOptions buildOptions();

// ----- Interface: RecoveryCodeDslConfigurer -----
public RecoveryCodeDslConfigurer codeLength(int length);
public RecoveryCodeDslConfigurer numberOfCodesToGenerate(int number);
public RecoveryCodeDslConfigurer emailOtpEndpoint(String endpoint);
public RecoveryCodeDslConfigurer smsOtpEndpoint(String endpoint);

// ----- Interface: RestDslConfigurer -----
// (No methods specific to RestDslConfigurer, inherits from AuthenticationFactorConfigurer)

// ----- Interface: StepDslConfigurer -----
public AuthenticationStepConfig toConfig();
public int getOrder();
public StepDslConfigurer order(int order);

// ===== Package: io.springsecurity.springsecurity6x.security.core.dsl.configurer.impl =====

// ----- Class: FormDslConfigurerImpl -----
public FormDslConfigurerImpl();
@Override
public FormDslConfigurer order(int order);
@Override
public FormDslConfigurer loginPage(String loginPageUrl);
@Override
public FormDslConfigurer loginProcessingUrl(String loginProcessingUrl);
@Override
public FormDslConfigurer usernameParameter(String usernameParameter);
@Override
public FormDslConfigurer passwordParameter(String passwordParameter);
@Override
public FormDslConfigurer defaultSuccessUrl(String defaultSuccessUrl, boolean alwaysUse);
@Override
public FormDslConfigurer failureUrl(String failureUrl);
@Override
public FormDslConfigurer permitAll();
@Override
public FormDslConfigurer successHandler(AuthenticationSuccessHandler successHandler);
@Override
public FormDslConfigurer failureHandler(AuthenticationFailureHandler failureHandler);
@Override
public FormDslConfigurer securityContextRepository(SecurityContextRepository repository);
@Override
public FormDslConfigurer rawFormLogin(SafeHttpFormLoginCustomizer customizer);
@Override
public FormDslConfigurer asep(Customizer<FormAsepAttributes> formAsepAttributesCustomizer);
@Override
protected FormDslConfigurerImpl self();

// ----- Class: MfaDslConfigurerImpl -----
public MfaDslConfigurerImpl(ApplicationContext applicationContext);
@Override
public MfaDslConfigurerImpl<H> order(int order);
@Override
public MfaDslConfigurerImpl<H> primaryAuthentication(Customizer<PrimaryAuthDslConfigurer> primaryAuthConfigCustomizer);
@Override
public MfaDslConfigurerImpl<H> form(Customizer<FormDslConfigurer> formConfigurerCustomizer);
@Override
public MfaDslConfigurerImpl<H> rest(Customizer<RestDslConfigurer> restConfigurerCustomizer);
private <O_FACTOR extends AuthenticationProcessingOptions, A_FACTOR extends BaseAsepAttributes, C_FACTOR extends AuthenticationFactorConfigurer<O_FACTOR, A_FACTOR, C_FACTOR>> MfaDslConfigurerImpl<H> configureMfaFactor(AuthType authType, Customizer<C_FACTOR> factorConfigurerCustomizer, Class<C_FACTOR> configurerInterfaceType);
@Override
public MfaDslConfigurerImpl<H> ott(Customizer<OttDslConfigurer> ottConfigurerCustomizer);
@Override
public MfaDslConfigurerImpl<H> passkey(Customizer<PasskeyDslConfigurer> passkeyConfigurerCustomizer);
@Override
public MfaDslConfigurerImpl<H> recoveryFlow(Customizer<RecoveryCodeDslConfigurer> recoveryConfigurerCustomizer);
@Override
public MfaDslConfigurerImpl<H> mfaContinuationHandler(MfaContinuationHandler continuationHandler);
@Override
public MfaDslConfigurerImpl<H> mfaFailureHandler(AuthenticationFailureHandler failureHandler);
@Override
public MfaDslConfigurerImpl<H> policyProvider(MfaPolicyProvider policyProvider);
@Override
public MfaDslConfigurerImpl<H> finalSuccessHandler(AuthenticationSuccessHandler handler);
@Override
public MfaDslConfigurerImpl<H> defaultRetryPolicy(Customizer<RetryPolicyDslConfigurer> c);
@Override
public MfaDslConfigurerImpl<H> defaultAdaptivePolicy(Customizer<AdaptiveDslConfigurer> c);
@Override
public MfaDslConfigurerImpl<H> defaultDeviceTrustEnabled(boolean enable);
@Override
public MfaDslConfigurerImpl<H> asep(Customizer<MfaAsepAttributes> mfaAsepAttributesCustomizer);
@Override
public AuthenticationFlowConfig build();

// ----- Class: OttDslConfigurerImpl -----
public OttDslConfigurerImpl(ApplicationContext applicationContext);
@Override
public OttDslConfigurer order(int order);
@Override
public OttDslConfigurer loginProcessingUrl(String url);
@Override
public OttDslConfigurer successHandler(AuthenticationSuccessHandler handler);
@Override
public OttDslConfigurer failureHandler(AuthenticationFailureHandler handler);
@Override
public OttDslConfigurer securityContextRepository(SecurityContextRepository repository);
@Override
public OttDslConfigurer defaultSubmitPageUrl(String url);
@Override
public OttDslConfigurer tokenGeneratingUrl(String url);
@Override
public OttDslConfigurer showDefaultSubmitPage(boolean show);
@Override
public OttDslConfigurer tokenService(OneTimeTokenService service);
@Override
public OttDslConfigurer tokenGenerationSuccessHandler(OneTimeTokenGenerationSuccessHandler handler);
@Override
public OttDslConfigurer asep(Customizer<OttAsepAttributes> ottAsepAttributesCustomizer);
@Override
protected OttDslConfigurerImpl self();

// ----- Class: PasskeyDslConfigurerImpl -----
public PasskeyDslConfigurerImpl();
@Override
public PasskeyDslConfigurer order(int order);
@Override
public PasskeyDslConfigurer loginProcessingUrl(String url);
@Override
public PasskeyDslConfigurer successHandler(AuthenticationSuccessHandler handler);
@Override
public PasskeyDslConfigurer failureHandler(AuthenticationFailureHandler handler);
@Override
public PasskeyDslConfigurer securityContextRepository(SecurityContextRepository repository);
@Override
public PasskeyDslConfigurer assertionOptionsEndpoint(String url);
@Override
public PasskeyDslConfigurer rpName(String rpName);
@Override
public PasskeyDslConfigurer rpId(String rpId);
@Override
public PasskeyDslConfigurer allowedOrigins(List<String> origins);
@Override
public PasskeyDslConfigurer allowedOrigins(String... origins);
@Override
public PasskeyDslConfigurer allowedOrigins(Set<String> origins);
@Override
public PasskeyDslConfigurer asep(Customizer<PasskeyAsepAttributes> passkeyAsepAttributesCustomizer);
@Override
protected PasskeyDslConfigurerImpl self();

// ----- Class: PrimaryAuthDslConfigurerImpl -----
public PrimaryAuthDslConfigurerImpl(ApplicationContext applicationContext);
@Override
public PrimaryAuthDslConfigurer formLogin(Customizer<FormDslConfigurer> formLoginCustomizer);
@Override
public PrimaryAuthDslConfigurer restLogin(Customizer<RestDslConfigurer> restLoginCustomizer);
@Override
public PrimaryAuthenticationOptions buildOptions();
public Customizer<FormDslConfigurer> getFormLoginCustomizer();
public Customizer<RestDslConfigurer> getRestLoginCustomizer();

// ----- Class: RecoveryCodeDslConfigurerImpl -----
public RecoveryCodeDslConfigurerImpl();
@Override
public RecoveryCodeDslConfigurer codeLength(int length);
@Override
public RecoveryCodeDslConfigurer numberOfCodesToGenerate(int number);
@Override
public RecoveryCodeDslConfigurer emailOtpEndpoint(String endpoint);
@Override
public RecoveryCodeDslConfigurer smsOtpEndpoint(String endpoint);
@Override
public RecoveryCodeDslConfigurer order(int order);
@Override
public RecoveryCodeDslConfigurer asep(Customizer<BaseAsepAttributes> asepAttributesCustomizer);
@Override
protected RecoveryCodeDslConfigurerImpl self();

// ----- Class: RestAuthenticationConfigurer -----
public RestAuthenticationConfigurer();
@Override
public void init(H http) throws Exception;
@Override
public void configure(H http) throws Exception;
public RestAuthenticationConfigurer<H> loginProcessingUrl(String loginProcessingUrl);
public RestAuthenticationConfigurer<H> successHandler(AuthenticationSuccessHandler successHandler);
public RestAuthenticationConfigurer<H> failureHandler(AuthenticationFailureHandler failureHandler);
public RestAuthenticationConfigurer<H> securityContextRepository(SecurityContextRepository repository);
public RestAuthenticationConfigurer<H> mfaInitiateUrl(String mfaInitiateUrl);

// ----- Class: RestDslConfigurerImpl -----
public RestDslConfigurerImpl();
@Override
public RestDslConfigurer order(int order);
@Override
public RestDslConfigurer asep(Customizer<RestAsepAttributes> restAsepAttributesCustomizer);
@Override
protected RestDslConfigurerImpl self();

// ===== Package: io.springsecurity.springsecurity6x.security.core.mfa =====

// ----- Class: AdaptiveConfig -----
// (Record - no explicit methods other than accessors and constructor)

// ----- Interface: AuditEventPublisher -----
public void publish(String eventType, Map<String, Object> details);

// ----- Interface: ChallengeGenerator -----
public Map<String,Object> generate(FactorContext ctx);

// ----- Class: ChallengeRouter -----
public ChallengeRouter(ChallengeGenerator generator);
public void writeNextChallenge(HttpServletResponse res, FactorContext ctx) throws IOException;
public void writeError(HttpServletResponse res, int status, String errorCode, String message) throws IOException;

// ----- Class: DefaultAuditEventPublisher -----
@Override
public void publish(String eventType, Map<String, Object> details);

// ----- Class: DefaultChallengeGenerator -----
@Override
public Map<String, Object> generate(FactorContext ctx);
private void handleOptionTypeError(Map<String, Object> payload, AuthType expectedAuthType, @Nullable AuthenticationProcessingOptions actualOptions, String sessionId);

// ----- Class: DefaultRecoveryService -----
@Override
public void initiateRecovery(HttpServletRequest request, HttpServletResponse response, RecoveryConfig config) throws IOException;

// ----- Class: DefaultTrustedDeviceService -----
@Override
public boolean isTrusted(HttpServletRequest request);
@Override
public String getDeviceId(HttpServletRequest request);
public void registerDevice(String deviceId);

// ----- Class: RecoveryConfig -----
public RecoveryConfig(String emailOtpEndpoint, String smsOtpEndpoint);
public String getEmailOtpEndpoint();
public String getSmsOtpEndpoint();

// ----- Interface: RecoveryService -----
public void initiateRecovery(HttpServletRequest request, HttpServletResponse response, RecoveryConfig config) throws IOException;

// ----- Class: RetryPolicy -----
public RetryPolicy(int maxAttempts);
public static RetryPolicy defaultPolicy();
public boolean canRetry(FactorContext factorContext, String stepId);
public int getMaxAttempts();

// ----- Class: RiskAssessmentResult -----
public RiskAssessmentResult(int score, boolean highRisk);
public int getScore();
public boolean isHighRisk();

// ----- Interface: RiskEngine -----
public RiskAssessmentResult assess(HttpServletRequest request);

// ----- Interface: TrustedDeviceService -----
public boolean isTrusted(HttpServletRequest request);
public String getDeviceId(HttpServletRequest request);

// ===== Package: io.springsecurity.springsecurity6x.security.core.mfa.context =====

// ----- Interface: ContextPersistence -----
@Nullable
public FactorContext contextLoad(HttpServletRequest request);
@Nullable
default FactorContext loadContext(String sessionId, HttpServletRequest request);
public void saveContext(@Nullable FactorContext ctx, HttpServletRequest request);
public void deleteContext(HttpServletRequest request);

// ----- Class: FactorContext -----
public FactorContext(String mfaSessionId, Authentication primaryAuthentication, MfaState initialState, @Nullable String flowTypeName);
public MfaState getCurrentState();
public void changeState(MfaState newState);
public void addCompletedFactor(AuthenticationStepConfig completedFactor);
public int getNumberOfCompletedFactors();
public int getLastCompletedFactorOrder();
public int incrementAttemptCount(@Nullable AuthType factorType);
public int getAttemptCount(@Nullable AuthType factorType);
public void recordAttempt(@Nullable AuthType factorType, boolean success, String detail);
public int incrementFailedAttempts(String factorTypeOrStepId);
public int getFailedAttempts(String factorTypeOrStepId);
public void resetFailedAttempts(String factorTypeOrStepId);
public void resetAllFailedAttempts();
public void setAttribute(String name, Object value);
@Nullable
public Object getAttribute(String name);
public void removeAttribute(String name);
public boolean isFullyAuthenticated();
public void setRegisteredMfaFactors(String key, @Nullable Object value);
public void updateLastActivityTimestamp();
@Override
public int getRetryCount();
@Override
public Set<AuthType> getAvailableFactors();
@Override
public List<AuthenticationStepConfig> getCompletedFactors();
@Override
public String getLastError();
@Override
public long getCreatedAt();
public String getMfaSessionId();
public Authentication getPrimaryAuthentication();
public String getUsername();
public String getFlowTypeName();
public void setFlowTypeName(String flowTypeName);
public AuthType getCurrentProcessingFactor();
public void setCurrentProcessingFactor(AuthType factor);
public String getCurrentStepId();
public void setCurrentStepId(String stepId);
public AuthenticationProcessingOptions getCurrentFactorOptions();
public void setCurrentFactorOptions(AuthenticationProcessingOptions options);
public boolean isMfaRequiredAsPerPolicy();
public void setMfaRequiredAsPerPolicy(boolean required);
public void setLastError(String error);
public void setRetryCount(int count);
// Inner Class: MfaAttemptDetail
public MfaAttemptDetail(@Nullable AuthType factorType, boolean success, String detail);
@Nullable public AuthType getFactorType();
public boolean isSuccess();
public Instant getTimestamp();
public String getDetail();
public boolean isCompleted();
public boolean isTerminal();
@Nullable
public AuthenticationStepConfig getNextStepToProcess(AuthenticationFlowConfig flowConfig, List<AuthType> userRegisteredFactors);
public List<AuthType> getRegisteredMfaFactors();
public List<AuthType> getRegisteredMfaFactors(AuthenticationFlowConfig mfaFlowConfig);
public void setRegisteredMfaFactors(List<AuthType> registeredFactors);
public void clearCurrentFactorProcessingState();
public boolean isFactorCompleted(String stepId);
// Inner Class: CompletedFactorInfo
public CompletedFactorInfo(AuthType factorType, String stepId, Instant completionTime, @Nullable AuthenticationProcessingOptions factorOptions);
@Override
public String toString();
public AuthType getFactorType();
public String getStepId();
public Instant getCompletionTime();
@Nullable public AuthenticationProcessingOptions getFactorOptions();

// ----- Interface: FactorContextExtensions -----
public int getRetryCount();
public Set<AuthType> getAvailableFactors();
public List<AuthenticationStepConfig> getCompletedFactors();
public String getLastError();
public long getCreatedAt();

// ----- Interface: FactorContextManager -----
public FactorContext load(HttpServletRequest req);
public void save(FactorContext ctx, HttpServletRequest req);
public void clear(HttpServletRequest req);

// ----- Class: FactorIdentifier -----
public FactorIdentifier(String flowName, String stepId);
@Override
public boolean equals(Object o);
@Override
public String toString();
public static FactorIdentifier of(String flowName, String stepId);

// ----- Class: HttpSessionContextPersistence -----
@Override
@Nullable
public FactorContext contextLoad(HttpServletRequest request);
@Override
public void saveContext(@Nullable FactorContext ctx, HttpServletRequest request);
@Override
public void deleteContext(HttpServletRequest request);

// ----- Class: SessionFactorContextManager -----
@Override
@Nullable
public FactorContext load(HttpServletRequest req);
@Override
public void save(@Nullable FactorContext ctx, HttpServletRequest req);
@Override
public void clear(HttpServletRequest req);

// ===== Package: io.springsecurity.springsecurity6x.security.core.mfa.policy =====

// ----- Class: DefaultMfaPolicyProvider -----
public DefaultMfaPolicyProvider(UserRepository userRepository, ApplicationContext applicationContext);
@Override
public void evaluateMfaRequirementAndDetermineInitialStep(Authentication primaryAuthentication, FactorContext ctx);
@Override
public void determineNextFactorToProcess(FactorContext ctx);
public void checkAllFactorsCompleted(FactorContext ctx, AuthenticationFlowConfig mfaFlowConfig);
@Nullable
private AuthType determineNextFactorInternal(List<AuthType> registeredFactors, List<AuthenticationStepConfig> completedFactorSteps, List<AuthenticationStepConfig> flowSteps);
@Override
public RetryPolicy getRetryPolicyForFactor(AuthType factorType, FactorContext ctx);
@Override
public boolean isFactorAvailableForUser(String username, AuthType factorType, FactorContext ctx);
@Override
public RetryPolicy getRetryPolicy(FactorContext factorContext, AuthenticationStepConfig step);
private Set<AuthType> parseRegisteredMfaFactorsFromUser(Users user);
public List<AuthType> getRegisteredMfaFactorsForUser(String username);
private Set<AuthType> parseMfaFactors(Users user);
@Nullable
private AuthenticationFlowConfig findMfaFlowConfig();
@Override
public Integer getRequiredFactorCount(String userId, String flowType);

// ----- Interface: MfaPolicyProvider -----
public void evaluateMfaRequirementAndDetermineInitialStep(Authentication primaryAuthentication, FactorContext ctx);
public void determineNextFactorToProcess(FactorContext ctx);
public RetryPolicy getRetryPolicyForFactor(AuthType factorType, FactorContext ctx);
public boolean isFactorAvailableForUser(String username, AuthType factorType, FactorContext ctx);
public RetryPolicy getRetryPolicy(FactorContext factorContext, AuthenticationStepConfig step);
default Integer getRequiredFactorCount(String userId, String flowType);

// ===== Package: io.springsecurity.springsecurity6x.security.enums =====

// ----- Enum: AuthType -----
// (Enum - no explicit methods other than standard enum methods)

// ----- Enum: ErrorCode -----
public String code();
public String message();

// ----- Enum: MfaEvent -----
// (Enum - no explicit methods other than standard enum methods)

// ----- Enum: MfaState -----
public boolean isTerminal();

// ----- Enum: StateType -----
// (Enum - no explicit methods other than standard enum methods)

// ----- Enum: TokenIssuer -----
// (Enum - no explicit methods other than standard enum methods)

// ----- Enum: TokenType -----
// (Enum - no explicit methods other than standard enum methods)

// ----- Enum: TokenTransportType -----
// (Enum - no explicit methods other than standard enum methods)

// ===== Package: io.springsecurity.springsecurity6x.security.filter =====

// ----- Class: JwtAuthorizationFilter -----
public JwtAuthorizationFilter(TokenService tokenService, LogoutHandler logoutHandler);
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException;

// ----- Class: JwtPreAuthenticationFilter -----
public JwtPreAuthenticationFilter(TokenService tokenService);
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException;

// ----- Class: JwtRefreshAuthenticationFilter -----
public JwtRefreshAuthenticationFilter(TokenService tokenService, LogoutHandler logoutHandler, AuthResponseWriter responseWriter);
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException;
private void handleFailure(HttpServletRequest request, HttpServletResponse response, int status, String errorCode, String errorMessage) throws IOException;

// ----- Class: MfaContinuationFilter -----
public MfaContinuationFilter(ContextPersistence contextPersistence, MfaPolicyProvider mfaPolicyProvider, AuthContextProperties authContextProperties, AuthResponseWriter responseWriter, ApplicationContext applicationContext);
private <T_STEP_OPT extends AuthenticationProcessingOptions> String determineUrlFromStepOptions(Optional<T_STEP_OPT> stepOptionsOpt, Function<T_STEP_OPT, String> urlExtractor, String defaultUrl, String urlDescription);
private <T extends AuthenticationProcessingOptions> Optional<T> getFirstMfaFactorOptionsByType(@Nullable AuthenticationFlowConfig mfaFlowConfig, AuthType factorType, Class<T> optionClass);
private <T extends AuthenticationProcessingOptions> Optional<T> getMfaFactorOptionsByStepId(@Nullable AuthenticationFlowConfig mfaFlowConfig, String stepId, AuthType factorType, Class<T> optionClass);
private <T extends AuthenticationProcessingOptions> Optional<T> getSpecificOptionFromStep(AuthenticationStepConfig step, Class<T> optionClass);
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException;
private void handleMfaInitiationRequest(HttpServletRequest request, HttpServletResponse response, FactorContext ctx, AuthenticationFlowConfig flowConfig) throws IOException, ServletException;
private void handleSelectFactorPageRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, FactorContext ctx) throws IOException, ServletException;
private void handleMfaOttRequestCodeUiPageRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, FactorContext ctx, AuthenticationFlowConfig flowConfig) throws IOException, ServletException;
private void handleFactorChallengeInputUiPageRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, FactorContext ctx, AuthType requestedFactor, AuthenticationFlowConfig flowConfig) throws IOException, ServletException;
private void handleTokenGenerationRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, FactorContext ctx, AuthenticationFlowConfig flowConfig) throws IOException, ServletException;
private void handleLoginProcessingRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, FactorContext ctx, AuthenticationFlowConfig flowConfig) throws IOException, ServletException;
private void handleInvalidContext(HttpServletRequest request, HttpServletResponse response, String errorCode, String errorMessage) throws IOException;
private void handleTerminalContext(HttpServletRequest request, HttpServletResponse response, FactorContext ctx) throws IOException;
private void handleConfigError(HttpServletResponse response, HttpServletRequest request, String errorCode, String errorMessage) throws IOException;
private void handleGenericError(HttpServletRequest request, HttpServletResponse response, FactorContext ctx, Exception e) throws IOException;
private void setFactorOptionsByStepIdInContext(FactorContext ctx, AuthType factorType, String stepId, @Nullable AuthenticationFlowConfig flowConfig);
private Optional<AuthenticationStepConfig> findStepConfigByFactorTypeAndMinOrder(AuthenticationFlowConfig flowConfig, AuthType factorType, int minOrderExclusive);
@Nullable
private AuthenticationFlowConfig findFlowConfigByName(String flowTypeName);

// ----- Class: MfaStepFilterWrapper -----
public MfaStepFilterWrapper(ConfiguredFactorFilterProvider configuredFactorFilterProvider, ContextPersistence contextPersistence, RequestMatcher mfaFactorProcessingMatcher);
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException;

// ----- Class: OttForwardingFilter -----
public OttForwardingFilter(CodeStore codeStore, String ottProcessingUrl, String failureUrl, String filterProcessesGetUrl, @Nullable String usernameParameterName, @Nullable String tokenParameterName, @Nullable ContextPersistence contextPersistence);
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException;
private String buildRedirectUrlWithReason(HttpServletRequest request, String baseUrl, String reason);

// ----- Class: RestAuthenticationFilter -----
public RestAuthenticationFilter(AuthenticationManager authenticationManager, ContextPersistence contextPersistence, ApplicationContext applicationContext);
public void setRequestMatcher(RequestMatcher requestMatcher);
public void setSuccessHandler(AuthenticationSuccessHandler successHandler);
public void setFailureHandler(AuthenticationFailureHandler failureHandler);
public void setSecurityContextRepository(SecurityContextRepository securityContextRepository);
public void setSecurityContextHolderStrategy(SecurityContextHolderStrategy securityContextHolderStrategy);
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException;
private Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException;
private void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authentication) throws IOException, ServletException;
@Nullable
private AuthenticationFlowConfig findMfaFlowConfig(String flowTypeName);
private void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException;
private String getOrCreateDeviceId(HttpServletRequest request);

// ===== Package: io.springsecurity.springsecurity6x.security.handler =====

// ----- Class: MfaFactorProcessingSuccessHandler -----
public MfaFactorProcessingSuccessHandler(ContextPersistence contextPersistence, MfaPolicyProvider mfaPolicyProvider, UnifiedAuthenticationSuccessHandler finalSuccessHandler, AuthResponseWriter responseWriter, ApplicationContext applicationContext, AuthContextProperties authContextProperties);
@Override
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authentication) throws IOException, ServletException;
@Override
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException;
@Nullable
private AuthenticationFlowConfig findMfaFlowConfig(String flowTypeName);
private void handleInvalidContext(HttpServletResponse response, HttpServletRequest request, String errorCode, String logMessage, @Nullable Authentication authentication) throws IOException;
private void handleConfigError(HttpServletResponse response, HttpServletRequest request, FactorContext ctx, String message) throws IOException;
private void handleGenericError(HttpServletResponse response, HttpServletRequest request, FactorContext ctx, String message) throws IOException;

// ----- Class: OneTimeRedirectSuccessHandler -----
public OneTimeRedirectSuccessHandler(String targetUrl, AuthResponseWriter responseWriter);
public OneTimeRedirectSuccessHandler(String targetUrl, AuthResponseWriter responseWriter, boolean dummy);
@Override
public void handle(HttpServletRequest request, HttpServletResponse response, OneTimeToken token) throws IOException, ServletException;

// ----- Class: OneTimeTokenCreationSuccessHandler -----
public OneTimeTokenCreationSuccessHandler(ContextPersistence contextPersistence, AuthContextProperties authContextProperties);
@Override
public void handle(HttpServletRequest request, HttpServletResponse response, OneTimeToken token) throws IOException, ServletException;

// ----- Class: SimpleRedirectSuccessHandler -----
public SimpleRedirectSuccessHandler(String targetUrl, AuthResponseWriter responseWriter);
public SimpleRedirectSuccessHandler(String targetUrl, AuthResponseWriter responseWriter, boolean dummy);
@Override
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException;

// ----- Class: UnifiedAuthenticationFailureHandler -----
public UnifiedAuthenticationFailureHandler(ContextPersistence contextPersistence, MfaPolicyProvider mfaPolicyProvider, AuthResponseWriter responseWriter, AuthContextProperties authContextProperties);
@Override
public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException;
private boolean isApiRequest(HttpServletRequest request);

// ----- Class: UnifiedAuthenticationSuccessHandler -----
public UnifiedAuthenticationSuccessHandler(ContextPersistence contextPersistence, MfaPolicyProvider mfaPolicyProvider, TokenService tokenService, AuthResponseWriter authResponseWriter, AuthContextProperties authContextProperties, ApplicationContext applicationContext);
@Override
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException;
private void handleFinalAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication finalAuthentication, @Nullable FactorContext factorContext) throws IOException;
private String getEffectiveDeviceId(HttpServletRequest request);
protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication);
@Nullable
private AuthenticationFlowConfig findFlowConfigByName(String flowTypeName);
private void handleConfigError(HttpServletResponse response, HttpServletRequest request, @Nullable FactorContext ctx, String message) throws IOException;
private void handleInvalidContext(HttpServletResponse response, HttpServletRequest request, String errorCode, String logMessage, @Nullable Authentication authentication) throws IOException;

// ===== Package: io.springsecurity.springsecurity6x.security.properties =====

// ----- Class: AuthContextProperties -----
// (Lombok @Data - getters/setters are auto-generated)
public StateType getStateType();
public void setStateType(StateType stateType);
public TokenTransportType getTokenTransportType();
public void setTokenTransportType(TokenTransportType tokenTransportType);
public TokenIssuer getTokenIssuer();
public void setTokenIssuer(TokenIssuer tokenIssuer);
public MfaSettings getMfa();
public void setMfa(MfaSettings mfa);
public JwtsTokenSettings getInternal();
public void setInternal(JwtsTokenSettings internal);
public OAuth2TokenSettings getOauth2();
public void setOauth2(OAuth2TokenSettings oauth2);
public long getAccessTokenValidity();
public void setAccessTokenValidity(long accessTokenValidity);
public long getRefreshTokenValidity();
public void setRefreshTokenValidity(long refreshTokenValidity);
public long getRefreshRotateThreshold();
public void setRefreshRotateThreshold(long refreshRotateThreshold);
public boolean isEnableRefreshToken();
public void setEnableRefreshToken(boolean enableRefreshToken);
public boolean isAllowMultipleLogins();
public void setAllowMultipleLogins(boolean allowMultipleLogins);
public int getMaxConcurrentLogins();
public void setMaxConcurrentLogins(int maxConcurrentLogins);
public boolean isCookieSecure();
public void setCookieSecure(boolean cookieSecure);
public String getTokenPrefix();
public void setTokenPrefix(String tokenPrefix);
public String getRolesClaim();
public void setRolesClaim(String rolesClaim);
public String getScopesClaim();
public void setScopesClaim(String scopesClaim);

// ----- Class: JwtsTokenSettings -----
// (Lombok @Data - getters/setters are auto-generated)
public String getLoginUri();
public void setLoginUri(String loginUri);
public String getLogoutUri();
public void setLogoutUri(String logoutUri);
public String getRefreshUri();
public void setRefreshUri(String refreshUri);

// ----- Class: MfaSettings -----
// (Lombok @Getter @Setter - getters/setters are auto-generated)
public String getInitiateUrl();
public void setInitiateUrl(String initiateUrl);
public String getSelectFactorUrl();
public void setSelectFactorUrl(String selectFactorUrl);
public String getFailureUrl();
public void setFailureUrl(String failureUrl);
public int getOtpTokenValiditySeconds();
public void setOtpTokenValiditySeconds(int otpTokenValiditySeconds);
public PasskeyFactorSettings getPasskeyFactor();
public void setPasskeyFactor(PasskeyFactorSettings passkeyFactor);
public OttFactorSettings getOttFactor();
public void setOttFactor(OttFactorSettings ottFactor);

// ----- Class: OAuth2TokenSettings -----
// (Lombok @Data - getters/setters are auto-generated)
public String getClientId();
public void setClientId(String clientId);
public String getClientSecret();
public void setClientSecret(String clientSecret);
public String getIssuerUri();
public void setIssuerUri(String issuerUri);
public String getTokenEndpoint();
public void setTokenEndpoint(String tokenEndpoint);
public String getScope();
public void setScope(String scope);

// ----- Class: OttFactorSettings -----
// (Lombok @Getter @Setter - getters/setters are auto-generated)
public String getRequestCodeUiUrl();
public void setRequestCodeUiUrl(String requestCodeUiUrl);
public String getCodeGenerationUrl();
public void setCodeGenerationUrl(String codeGenerationUrl);
public String getCodeSentUrl();
public void setCodeSentUrl(String codeSentUrl);
public String getChallengeUrl();
public void setChallengeUrl(String challengeUrl);
public String getLoginProcessingUrl();
public void setLoginProcessingUrl(String loginProcessingUrl);
public String getDefaultFailureUrl();
public void setDefaultFailureUrl(String defaultFailureUrl);
public int getTokenValiditySeconds();
public void setTokenValiditySeconds(int tokenValiditySeconds);
public String getSingleOttRequestEmailUrl();
public void setSingleOttRequestEmailUrl(String singleOttRequestEmailUrl);
public String getSingleOttCodeGenerationUrl();
public void setSingleOttCodeGenerationUrl(String singleOttCodeGenerationUrl);
public String getSingleOttChallengeUrl();
public void setSingleOttChallengeUrl(String singleOttChallengeUrl);

// ----- Class: PasskeyFactorSettings -----
// (Lombok @Getter @Setter - getters/setters are auto-generated)
public String getChallengeUrl();
public void setChallengeUrl(String challengeUrl);
public String getDefaultFailureUrl();
public void setDefaultFailureUrl(String defaultFailureUrl);
public int getTimeoutSeconds();
public void setTimeoutSeconds(int timeoutSeconds);
public String getRegistrationRequestUrl();
public void setRegistrationRequestUrl(String registrationRequestUrl);
public String getRegistrationProcessingUrl();
public void setRegistrationProcessingUrl(String registrationProcessingUrl);

// ===== Package: io.springsecurity.springsecurity6x.security.service.ott =====

// ----- Interface: CodeStore -----
public void save(String code, OneTimeToken token, Duration duration);
public OneTimeToken consume(String code);

// ----- Class: EmailOneTimeTokenService -----
public EmailOneTimeTokenService(EmailService emailService, CodeStore codeStore, AuthContextProperties authContextProperties);
public OneTimeToken generateAndSendVerificationCode(String username, String emailPurpose);
public OneTimeToken generateAndSendMagicLink(GenerateOneTimeTokenRequest request, String loginProcessingPath, String emailPurpose);
@Override
public OneTimeToken generate(GenerateOneTimeTokenRequest request);
@Override
public OneTimeToken consume(OneTimeTokenAuthenticationToken authenticationToken);

// ----- Class: EmailService -----
public EmailService(JavaMailSender mailSender);
public void sendHtmlMessage(String to, String subject, String htmlBody);

// ----- Class: InMemoryCodeStore -----
@Override
public void save(String code, OneTimeToken token, Duration duration);
@Override
public OneTimeToken consume(String code);

// ----- Class: MagicLinkHandler -----
@Override
public void handle(HttpServletRequest request, HttpServletResponse response, OneTimeToken token) throws IOException;

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.action =====

// ----- Class: AbstractMfaStateAction -----
protected AbstractMfaStateAction(FactorContextStateAdapter factorContextAdapter, StateContextHelper stateContextHelper);
@Override
public final void execute(StateContext<MfaState, MfaEvent> context);
protected abstract void doExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext) throws Exception;
protected String extractSessionId(StateContext<MfaState, MfaEvent> context);
protected FactorContext extractFactorContext(StateContext<MfaState, MfaEvent> context);
protected void updateStateMachineVariables(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);
protected void handleError(StateContext<MfaState, MfaEvent> context, Exception e);
protected boolean canExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);

// ----- Class: CompleteMfaAction -----
public CompleteMfaAction(FactorContextStateAdapter factorContextAdapter, StateContextHelper stateContextHelper);
@Override
protected void doExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext) throws Exception;
private void performCompletionTasks(FactorContext factorContext);
@Override
protected boolean canExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);

// ----- Class: HandleFailureAction -----
public HandleFailureAction(FactorContextStateAdapter factorContextAdapter, StateContextHelper stateContextHelper);
@Override
protected void doExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext) throws Exception;

// ----- Class: InitializeMfaAction -----
public InitializeMfaAction(FactorContextStateAdapter factorContextAdapter, StateContextHelper stateContextHelper);
@Override
protected void doExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext) throws Exception;

// ----- Class: InitiateChallengeAction -----
public InitiateChallengeAction(FactorContextStateAdapter factorContextAdapter, StateContextHelper stateContextHelper);
@Override
protected void doExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext) throws Exception;

// ----- Interface: MfaStateAction -----
default boolean validateContext(FactorContext context);
public String getActionName();

// ----- Class: SelectFactorAction -----
public SelectFactorAction(FactorContextStateAdapter factorContextAdapter, StateContextHelper stateContextHelper);
@Override
protected void doExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext) throws Exception;

// ----- Class: VerifyFactorAction -----
public VerifyFactorAction(FactorContextStateAdapter factorContextAdapter, StateContextHelper stateContextHelper);
@Override
protected void doExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext) throws Exception;
private AuthenticationStepConfig createCompletedStep(String stepId, String factorType, FactorContext factorContext);
private void updateVerificationSuccess(FactorContext factorContext, AuthenticationStepConfig completedStep);
private String extractFactorTypeFromContext(StateContext<MfaState, MfaEvent> context);
@Override
protected boolean canExecute(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.adapter =====

// ----- Interface: FactorContextStateAdapter -----
public Map<Object, Object> toStateMachineVariables(FactorContext factorContext);
public void updateFactorContext(StateMachine<MfaState, MfaEvent> stateMachine, FactorContext factorContext);
public void updateFactorContext(StateContext<MfaState, MfaEvent> stateContext, FactorContext factorContext);

// ----- Class: FactorContextStateAdapterImpl -----
@Override
public Map<Object, Object> toStateMachineVariables(FactorContext factorContext);
@Override
public void updateFactorContext(StateMachine<MfaState, MfaEvent> stateMachine, FactorContext factorContext);
@Override
public void updateFactorContext(StateContext<MfaState, MfaEvent> stateContext, FactorContext factorContext);
private void updateFactorContextFromVariables(FactorContext factorContext, Map<Object, Object> variables);
private String serializeCompletedFactors(FactorContext factorContext);
private String serializeAvailableFactors(Set<?> availableFactors);

// ----- Interface: MfaEventAdapter -----
public MfaEvent determineEvent(String action, FactorContext context);
public boolean canTriggerEvent(MfaEvent event, FactorContext context);
public int getMaxRetries();
public long calculateSessionDuration(FactorContext context);
default Message<MfaEvent> toStateMachineMessage(MfaEvent event, FactorContext context);

// ----- Class: MfaEventAdapterImpl -----
public MfaEventAdapterImpl(AuthContextProperties authContextProperties);
@Override
public MfaEvent determineEvent(String action, FactorContext context);
@Override
public boolean canTriggerEvent(MfaEvent event, FactorContext context);
@Override
public int getMaxRetries();
@Override
public long calculateSessionDuration(FactorContext context);
@Override
public Message<MfaEvent> toStateMachineMessage(MfaEvent event, FactorContext context);
private MfaEvent mapActionToEvent(String action);
private MfaEvent adjustEventBasedOnContext(MfaEvent event, FactorContext context);
private boolean isRetryEvent(MfaEvent event);
private boolean isSessionExpired(FactorContext context);
public String getEventDescription(MfaEvent event);

// ----- Class: MfaStateMachineFeature -----
@Override
public String getId();
@Override
public void apply(HttpSecurity http, PlatformContext context);

// ----- Class: StateTransitionAdapter -----
public boolean isValidTransition(MfaState currentState, MfaEvent event);
public MfaState getTargetState(MfaState currentState, MfaEvent event);
public TransitionInfo extractTransitionInfo(Transition<MfaState, MfaEvent> transition);
// Inner Record: TransitionInfo (no explicit methods other than accessors and constructor)

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.config =====

// ----- Class: InMemoryPersistenceConfig -----
public StateMachinePersist<MfaState, MfaEvent, String> stateMachinePersist();
public StateMachinePersister<MfaState, MfaEvent, String> stateMachinePersister(StateMachinePersist<MfaState, MfaEvent, String> stateMachinePersist);

// ----- Class: MfaStateMachineConfiguration -----
public MfaStateMachineConfiguration(InitializeMfaAction initializeMfaAction, SelectFactorAction selectFactorAction, InitiateChallengeAction initiateChallengeAction, VerifyFactorAction verifyFactorAction, CompleteMfaAction completeMfaAction, HandleFailureAction handleFailureAction, AllFactorsCompletedGuard allFactorsCompletedGuard, RetryLimitGuard retryLimitGuard);
@Override
public void configure(StateMachineConfigurationConfigurer<MfaState, MfaEvent> config) throws Exception;
@Override
public void configure(StateMachineStateConfigurer<MfaState, MfaEvent> states) throws Exception;
@Override
public void configure(StateMachineTransitionConfigurer<MfaState, MfaEvent> transitions) throws Exception;
@Bean
public StateMachineListener<MfaState, MfaEvent> listener();

// ----- Class: RedisConfiguration -----
@Bean(name = "stateMachineRedisTemplate")
@ConditionalOnMissingBean(name = "stateMachineRedisTemplate")
public RedisTemplate<String, byte[]> stateMachineRedisTemplate(RedisConnectionFactory connectionFactory);

// ----- Class: RedisPersistenceConfig -----
public RedisPersistenceConfig(StateMachineProperties properties);
@Bean
@Primary
public StateMachinePersist<MfaState, MfaEvent, String> stateMachinePersist(@Qualifier("stateMachineRedisTemplate") RedisTemplate<String, byte[]> redisTemplate);
@Bean
public StateMachinePersister<MfaState, MfaEvent, String> stateMachinePersister(StateMachinePersist<MfaState, MfaEvent, String> stateMachinePersist);

// ----- Class: StateMachineAutoConfiguration -----
public StateMachineAutoConfiguration(StateMachineProperties properties, AuthContextProperties authContextProperties);
@Bean
@ConditionalOnProperty(prefix = "security.statemachine.mfa", name = "enableMetrics", havingValue = "true", matchIfMissing = true)
public MfaStateChangeListener mfaStateChangeListener();

// ----- Class: StateMachineProperties -----
// (Lombok @Data - getters/setters are auto-generated)
public boolean isEnabled();
public void setEnabled(boolean enabled);
public boolean isEnablePersistence();
public void setEnablePersistence(boolean enablePersistence);
public Integer getContextTtlMinutes();
public void setContextTtlMinutes(Integer contextTtlMinutes);
public MfaProperties getMfa();
public void setMfa(MfaProperties mfa);
public RedisProperties getRedis();
public void setRedis(RedisProperties redis);
// Inner Class: MfaProperties
public boolean isEnableMetrics();
public void setEnableMetrics(boolean enableMetrics);
public Integer getMaxRetries();
public void setMaxRetries(Integer maxRetries);
public Integer getSessionTimeoutMinutes();
public void setSessionTimeoutMinutes(Integer sessionTimeoutMinutes);
// Inner Class: RedisProperties
public boolean isEnabled();
public void setEnabled(boolean enabled);
public Integer getTtlMinutes();
public void setTtlMinutes(Integer ttlMinutes);
public String getKeyPrefix();
public void setKeyPrefix(String keyPrefix);

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.core =====

// ----- Class: InMemoryStateMachinePersist -----
@Override
public void write(StateMachineContext<MfaState, MfaEvent> context, String contextObj) throws Exception;
@Override
public StateMachineContext<MfaState, MfaEvent> read(String contextObj) throws Exception;
public void delete(String contextObj);

// ----- Interface: MfaEventListener -----
public void onEvent(MfaEvent event, FactorContext context, String sessionId);

// ----- Interface: MfaEventPublisher -----
public void publishStateChange(String sessionId, MfaState state, MfaEvent event);
public void publishError(String sessionId, Exception error);
public void publishCustomEvent(String eventType, Object payload);

// ----- Class: MfaEventPublisherImpl -----
public MfaEventPublisherImpl(ApplicationEventPublisher applicationEventPublisher);
@Override
public void publishStateChange(String sessionId, MfaState state, MfaEvent event);
@Override
public void publishError(String sessionId, Exception error);
@Override
public void publishCustomEvent(String eventType, Object payload);
// Inner Class: MfaStateChangeEvent
public MfaStateChangeEvent(Object source, String sessionId, MfaState state, MfaEvent event, LocalDateTime timestamp);
public Object getSource();
public String getSessionId();
public MfaState getState();
public MfaEvent getEvent();
public LocalDateTime getTimestamp();
// Inner Class: MfaErrorEvent
public MfaErrorEvent(Object source, String sessionId, Exception error, LocalDateTime timestamp);
public Object getSource();
public String getSessionId();
public Exception getError();
public LocalDateTime getTimestamp();

// ----- Interface: MfaStateMachineFactory -----
public StateMachine<MfaState, MfaEvent> createStateMachine(String machineId);
public StateMachine<MfaState, MfaEvent> createStateMachine();
public StateMachine<MfaState, MfaEvent> restoreStateMachine(String machineId);
public void releaseStateMachine(String machineId);

// ----- Class: MfaStateMachineFactoryImpl -----
public MfaStateMachineFactoryImpl(StateMachineFactory<MfaState, MfaEvent> stateMachineFactory, StateMachinePersister<MfaState, MfaEvent, String> stateMachinePersister);
@Override
public StateMachine<MfaState, MfaEvent> createStateMachine(String machineId);
@Override
public StateMachine<MfaState, MfaEvent> createStateMachine();
@Override
public StateMachine<MfaState, MfaEvent> restoreStateMachine(String machineId);
@Override
public void releaseStateMachine(String machineId);
private String generateMachineId();
public boolean isStateMachineValid(StateMachine<MfaState, MfaEvent> stateMachine);

// ----- Interface: MfaStateMachineService -----
public void initializeStateMachine(FactorContext context, HttpServletRequest request);
public boolean sendEvent(MfaEvent event, FactorContext context, HttpServletRequest request);
public MfaState getCurrentState(String sessionId);
public void releaseStateMachine(String sessionId);

// ----- Class: MfaStateMachineServiceImpl -----
// Inner Class: CachedStateMachine
CachedStateMachine(StateMachine<MfaState, MfaEvent> stateMachine);
boolean isExpired(int ttlMinutes);
public MfaStateMachineServiceImpl(MfaStateMachineFactory stateMachineFactory, StateMachinePersister<MfaState, MfaEvent, String> stateMachinePersister, FactorContextStateAdapter factorContextAdapter, ContextPersistence contextPersistence, MfaEventPublisher eventPublisher);
@Override
public void initializeStateMachine(FactorContext context, HttpServletRequest request);
@Override
public boolean sendEvent(MfaEvent event, FactorContext context, HttpServletRequest request);
@Override
public MfaState getCurrentState(String sessionId);
@Override
public void releaseStateMachine(String sessionId);
private StateMachine<MfaState, MfaEvent> acquireStateMachine(String sessionId, FactorContext context);
private void persistStateMachine(StateMachine<MfaState, MfaEvent> stateMachine, String sessionId);
private boolean isStateMachineValid(StateMachine<MfaState, MfaEvent> stateMachine);
private StateMachine<MfaState, MfaEvent> getActiveStateMachine(String sessionId);
private void cleanupExpiredMachines();
public void shutdown();

// ----- Class: RedisStateMachinePersist -----
public RedisStateMachinePersist(RedisTemplate<String, byte[]> redisTemplate, int ttlMinutes);
@Override
public void write(StateMachineContext<MfaState, MfaEvent> context, String contextObj) throws Exception;
@Override
public StateMachineContext<MfaState, MfaEvent> read(String contextObj) throws Exception;
public void delete(String contextObj);
private String generateKey(String sessionId);
private byte[] serialize(StateMachineContext<MfaState, MfaEvent> context) throws IOException;
private StateMachineContext<MfaState, MfaEvent> deserialize(byte[] data) throws IOException, ClassNotFoundException;
public Map<String, StateMachineContext<MfaState, MfaEvent>> readAll();

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.enums =====
// (Skipped as per previous instruction for enums)

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.guard =====

// ----- Class: AbstractMfaStateGuard -----
@Override
public final boolean evaluate(StateContext<MfaState, MfaEvent> context);
protected abstract boolean doEvaluate(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);
protected FactorContext extractFactorContext(StateContext<MfaState, MfaEvent> context);
public Guard<MfaState, MfaEvent> negate();
@Override
public abstract String getFailureReason();
@Override
public abstract String getGuardName();

// ----- Class: AllFactorsCompletedGuard -----
public AllFactorsCompletedGuard(MfaPolicyProvider mfaPolicyProvider);
@Override
protected boolean doEvaluate(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);
private int getRequiredFactorCount(FactorContext factorContext);
private int getDefaultRequiredFactorCount(String flowType);
@Override
public String getFailureReason();
public boolean isFactorTypeCompleted(FactorContext factorContext, String factorType);
public boolean needsMoreFactors(FactorContext factorContext);
@Override
public String getGuardName();

// ----- Class: FactorAvailabilityGuard -----
public FactorAvailabilityGuard();
@Override
protected boolean doEvaluate(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);
@Override
public String getGuardName();
@Override
public String getFailureReason();

// ----- Interface: MfaStateGuard -----
public String getGuardName();
public String getFailureReason();

// ----- Class: MfaPolicyGuard -----
public MfaPolicyGuard(MfaPolicyProvider mfaPolicyProvider);
@Override
protected boolean doEvaluate(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);
@Override
public String getFailureReason();
@Override
public String getGuardName();
public boolean allRequiredFactorsCompleted(FactorContext factorContext);
public boolean needsAdditionalFactors(FactorContext factorContext);

// ----- Class: RetryLimitGuard -----
public RetryLimitGuard(AuthContextProperties authContextProperties);
@Override
protected boolean doEvaluate(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);
private int getMaxRetries();
private int getFactorMaxRetries(String factorType);
private Integer getFactorRetryCount(FactorContext factorContext, String factorType);
public void incrementRetryCount(FactorContext factorContext);
public void resetRetryCount(FactorContext factorContext, String factorType);
@Override
public String getFailureReason();
public int getRemainingRetries(FactorContext factorContext);
public int getFactorRemainingRetries(FactorContext factorContext, String factorType);
@Override
public String getGuardName();

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.integration =====

// ----- Class: MfaStateMachineConfigurer -----
public MfaStateMachineConfigurer(MfaStateMachineService stateMachineService);
@Override
public void init(PlatformContext ctx, PlatformConfig config);
@Override
public void configure(FlowContext fc) throws Exception;
@Override
public int getOrder();

// ----- Interface: StateMachineFilterIntegration -----
public boolean preProcess(HttpServletRequest request, HttpServletResponse response, FactorContext context);
public void postProcess(HttpServletRequest request, HttpServletResponse response, FactorContext context, Object result);
public boolean canProceed(HttpServletRequest request, FactorContext context);

// ----- Class: StateMachineFilterIntegrationImpl -----
public StateMachineFilterIntegrationImpl(MfaStateMachineService stateMachineService);
@Override
public boolean preProcess(HttpServletRequest request, HttpServletResponse response, FactorContext context);
@Override
public void postProcess(HttpServletRequest request, HttpServletResponse response, FactorContext context, Object result);
@Override
public boolean canProceed(HttpServletRequest request, FactorContext context);
private MfaEvent determineEventFromResult(HttpServletRequest request, Object result);
private boolean isBlockingState(MfaState state);

// ----- Interface: StateMachineHandlerAdvice -----
public boolean beforeHandler(String handlerName, FactorContext context, HttpServletRequest request);
public void afterHandler(String handlerName, FactorContext context, HttpServletRequest request, Object result);
public void onHandlerError(String handlerName, FactorContext context, HttpServletRequest request, Exception error);

// ----- Class: StateMachineHandlerAdviceImpl -----
public StateMachineHandlerAdviceImpl(MfaStateMachineService stateMachineService);
@Override
public boolean beforeHandler(String handlerName, FactorContext context, HttpServletRequest request);
@Override
public void afterHandler(String handlerName, FactorContext context, HttpServletRequest request, Object result);
@Override
public void onHandlerError(String handlerName, FactorContext context, HttpServletRequest request, Exception error);
private boolean isHandlerAllowedInState(String handlerName, MfaState currentState);
private MfaEvent determineEventFromHandler(String handlerName, Object result, FactorContext context);
private MfaEvent determineErrorEvent(Exception error);

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.listener =====

// ----- Class: MfaStateChangeListener -----
@Override
public void stateChanged(State<MfaState, MfaEvent> from, State<MfaState, MfaEvent> to);
@Override
public void transition(Transition<MfaState, MfaEvent> transition);
@Override
public void stateMachineError(org.springframework.statemachine.StateMachine<MfaState, MfaEvent> stateMachine, Exception exception);
@Override
public void onSuccessfulTransition(String sessionId, MfaState fromState, MfaState toState, MfaEvent event);
@Override
public void onFailedTransition(String sessionId, MfaState currentState, MfaEvent event, Exception error);
private void recordStateChange(String fromState, String toState);
private void handleStateMachineError(String machineId, Exception exception);
public long getStateChangeCount(String fromState, String toState);
public long getEventCount(String event);

// ----- Interface: MfaStateMachineListener -----
public void onSuccessfulTransition(String sessionId, MfaState fromState, MfaState toState, MfaEvent event);
public void onFailedTransition(String sessionId, MfaState currentState, MfaEvent event, Exception error);

// ===== Package: io.springsecurity.springsecurity6x.security.statemachine.support =====

// ----- Class: StateContextHelper -----
public StateContextHelper(ContextPersistence contextPersistence);
public FactorContext extractFactorContext(StateContext<MfaState, MfaEvent> context);
private Authentication extractAuthentication(StateContext<MfaState, MfaEvent> context, String mfaSessionId);
private void restoreFactorContextFields(FactorContext factorContext, Map<Object, Object> variables);
private void restoreCompletedFactors(FactorContext factorContext, Map<Object, Object> variables);
private List<AuthenticationStepConfig> parseCompletedFactors(String completedFactorsStr, String flowTypeName);
private void restoreAvailableFactors(FactorContext factorContext, Map<Object, Object> variables);
private void restoreAdditionalData(FactorContext factorContext, Map<Object, Object> variables);
private MfaState extractCurrentState(Map<Object, Object> variables);
private HttpServletRequest extractHttpServletRequest(StateContext<MfaState, MfaEvent> context);
public void saveFactorContext(StateContext<MfaState, MfaEvent> context, FactorContext factorContext);
private String serializeCompletedFactors(List<AuthenticationStepConfig> completedFactors);

// ===== Package: io.springsecurity.springsecurity6x.security.token.creator =====

// ----- Interface: TokenCreator -----
public String createToken(TokenRequest request);

// ----- Class: JwtTokenCreator -----
public JwtTokenCreator(SecretKey secretKey);
@Override
public String createToken(TokenRequest req);

// ----- Class: OAuth2TokenCreator -----
public OAuth2TokenCreator(OAuth2TokenProvider tokenProvider);
@Override
public String createToken(TokenRequest request);

// ----- Class: TokenRequest -----
// (Lombok @Data @Builder - getters/setters/builder are auto-generated)

// ===== Package: io.springsecurity.springsecurity6x.security.token.parser =====

// ----- Class: JwtTokenParser -----
public JwtTokenParser(Key secretKey);
@Override
public ParsedJwt parse(String token);
@Override
public boolean isValidAccessToken(String token);
@Override
public boolean isValidRefreshToken(String token);
private Claims getClaims(String token);

// ----- Class: OAuth2TokenParser -----
public OAuth2TokenParser(OAuth2ResourceClient resourceClient);
@Override
public ParsedJwt parse(String token);
@Override
public boolean isValidAccessToken(String token);
@Override
public boolean isValidRefreshToken(String token);

// ----- Class: ParsedJwt -----
// (Record - no explicit methods other than accessors and constructor)

// ----- Interface: TokenParser -----
public ParsedJwt parse(String token);
public boolean isValidAccessToken(String token);
public boolean isValidRefreshToken(String token);

// ===== Package: io.springsecurity.springsecurity6x.security.token.service =====

// ----- Class: JwtTokenService -----
public JwtTokenService(TokenValidator tokenValidator, TokenCreator tokenCreator, RefreshTokenStore tokenStore, TokenTransportStrategy transport, AuthContextProperties props, ObjectMapper objectMapper);
@Override
public String createAccessToken(Authentication authentication, String deviceId);
@Override
public String createRefreshToken(Authentication authentication, String deviceId);
private String getToken(Authentication authentication, String tokenType, long validity, String deviceId);
@Override
public RefreshResult refresh(String refreshToken);
@Override
public TokenTransportResult prepareTokensForTransport(String accessToken, String refreshToken);
@Override
public TokenTransportResult prepareClearTokens();
@Override
public void blacklistRefreshToken(String refreshToken, String username, String reason);
@Override
public boolean validateAccessToken(String token);
@Override
public boolean validateRefreshToken(String token);
@Override
public void invalidateRefreshToken(String refreshToken);
@Override
public Authentication getAuthentication(String token);
@Override
public String resolveAccessToken(HttpServletRequest request);
@Override
public String resolveRefreshToken(HttpServletRequest request);
@Override
public TokenTransportStrategy getUnderlyingTokenTransportStrategy();
@Override
public AuthContextProperties properties();
@Override
public ObjectMapper getObjectMapper();

// ----- Class: OAuth2TokenService -----
public OAuth2TokenService(TokenCreator tokenCreator, TokenValidator tokenValidator, TokenTransportStrategy transport, AuthContextProperties props);
@Override
public String createAccessToken(Authentication authentication, String deviceId);
@Override
public String resolveRefreshToken(HttpServletRequest request);
@Override
public TokenTransportStrategy getUnderlyingTokenTransportStrategy();
@Override
public String createRefreshToken(Authentication authentication, String deviceId);
@Override
public RefreshResult refresh(String refreshToken);
@Override
public boolean validateAccessToken(String token);
@Override
public boolean validateRefreshToken(String token);
@Override
public void invalidateRefreshToken(String refreshToken);
@Override
public Authentication getAuthentication(String token);
@Override
public boolean shouldRotateRefreshToken(String refreshToken);
@Override
public TokenParser tokenParser();
@Override
public String resolveAccessToken(HttpServletRequest request);
@Override
public AuthContextProperties properties();
@Override
public void blacklistRefreshToken(String refreshToken, String username, String reason);
@Override
public ObjectMapper getObjectMapper();
@Override
public TokenTransportResult prepareTokensForTransport(String accessToken, String refreshToken);
@Override
public TokenTransportResult prepareClearTokens();

// ----- Interface: TokenProvider -----
public String createAccessToken(Authentication authentication, String deviceId);
public String createRefreshToken(Authentication authentication, String deviceId);
public TokenService.RefreshResult refresh(String refreshToken);

// ----- Interface: TokenService -----
// Inner Record: RefreshResult (no explicit methods other than accessors and constructor)
// Inner Interface: TokenServicePropertiesProvider
public long getAccessTokenValidity();
public long getRefreshTokenValidity();
public String getCookiePath();
public boolean isCookieSecure();
public String getRefreshTokenCookieName();
public String getAccessTokenCookieName();
public AuthContextProperties properties();
public void blacklistRefreshToken(String refreshToken, String username, String reason);
public ObjectMapper getObjectMapper();
public TokenTransportResult prepareTokensForTransport(String accessToken, String refreshToken);
public TokenTransportResult prepareClearTokens();
public String resolveAccessToken(HttpServletRequest request);
public String resolveRefreshToken(HttpServletRequest request);
public TokenTransportStrategy getUnderlyingTokenTransportStrategy();

// ===== Package: io.springsecurity.springsecurity6x.security.token.store =====

// ----- Class: JwtRefreshTokenStore -----
public JwtRefreshTokenStore(TokenParser tokenParser, AuthContextProperties props);
private String deviceKey(String username, String deviceId);
@Override
public void save(String refreshToken, String username);
private void evictAndBlacklist(String tokenKey, String username, String reason);
@Override
public String getUsername(String refreshToken);
@Override
public void blacklist(String token, String username, String reason);
@Override
public void blacklistDevice(String username, String deviceId, String reason);
@Override
public boolean isBlacklisted(String token);
@Override
public synchronized void remove(String refreshToken);
@Scheduled(fixedRate = 3600000)
public void cleanupExpiredBlacklistEntries();

// ----- Class: JwtRefreshTokenStore2 -----
// (File is commented out, so no methods listed)

// ----- Class: OAuth2RefreshTokenStore -----
@Override
public void save(String refreshToken, String username);
@Override
public String getUsername(String refreshToken);
@Override
public void blacklist(String token, String username, String reason);
@Override
public void blacklistDevice(String token, String username, String reason);
@Override
public boolean isBlacklisted(String token);
@Override
public void remove(String refreshToken);

// ----- Interface: RefreshTokenStore -----
public void save(String token, String username);
public void remove(String token);
public String getUsername(String refreshToken);
public void blacklist(String token, String username, String reason);
public void blacklistDevice(String token, String username, String reason);
public boolean isBlacklisted(String token);

// ----- Class: TokenInfo -----
public TokenInfo(String username, Instant expiration);
public TokenInfo(String username, Instant expiration, String reason);

// ===== Package: io.springsecurity.springsecurity6x.security.token.transport =====

// ----- Class: AbstractTokenTransportStrategy -----
protected AbstractTokenTransportStrategy(AuthContextProperties props);
protected String extractCookie(HttpServletRequest request, String name);
protected void addCookie(HttpServletResponse response, String name, String value, int maxAgeSeconds, String path);
protected void removeCookie(HttpServletResponse response, String name, String path);
protected void writeJson(HttpServletResponse response, Object body);

// ----- Class: CookieTokenStrategy -----
protected CookieTokenStrategy(AuthContextProperties props);
@Override
public String resolveAccessToken(HttpServletRequest request);
@Override
public String resolveRefreshToken(HttpServletRequest request);
@Override
public TokenTransportResult prepareTokensForTransport(String accessToken, String refreshToken, TokenService.TokenServicePropertiesProvider tokenServiceProperties);
@Override
public TokenTransportResult prepareTokensForClear(TokenService.TokenServicePropertiesProvider tokenServiceProperties);

// ----- Class: HeaderCookieTokenStrategy -----
public HeaderCookieTokenStrategy(AuthContextProperties props);
@Override
public String resolveAccessToken(HttpServletRequest request);
@Override
public String resolveRefreshToken(HttpServletRequest request);
@Override
public TokenTransportResult prepareTokensForWrite(String accessToken, String refreshToken, TokenService.TokenServicePropertiesProvider propsProvider);
@Override
public TokenTransportResult prepareTokensForClear(TokenService.TokenServicePropertiesProvider propsProvider);

// ----- Class: HeaderTokenStrategy -----
public HeaderTokenStrategy(AuthContextProperties props);
@Override
public String resolveAccessToken(HttpServletRequest request);
@Override
public String resolveRefreshToken(HttpServletRequest request);
@Override
public TokenTransportResult prepareTokensForWrite(String accessToken, String refreshToken, TokenService.TokenServicePropertiesProvider tokenServiceProperties);
@Override
public TokenTransportResult prepareTokensForClear(TokenService.TokenServicePropertiesProvider tokenServiceProperties);

// ----- Class: TokenResponse -----
// (Record - no explicit methods other than accessors and constructor)

// ----- Interface: TokenTransportStrategy -----
public String resolveAccessToken(HttpServletRequest request);
public String resolveRefreshToken(HttpServletRequest request);
public TokenTransportResult prepareTokensForWrite(String accessToken, String refreshToken, TokenService.TokenServicePropertiesProvider tokenServiceProperties);
public TokenTransportResult prepareTokensForClear(TokenService.TokenServicePropertiesProvider tokenServiceProperties);

// ----- Class: TokenTransportStrategyFactory -----
public static TokenTransportStrategy create(AuthContextProperties props);

// ----- Class: TokenTransportResult -----
// (Lombok @Getter @Builder - getters/builder are auto-generated)
// Inner Class: TokenTransportResultBuilder (Lombok generated)

// ===== Package: io.springsecurity.springsecurity6x.security.token.validator =====

// ----- Class: JwtTokenValidator -----
public JwtTokenValidator(TokenParser tokenParser, RefreshTokenStore refreshTokenStore, long rotateThresholdMillis);
@Override
public boolean validateAccessToken(String token);
@Override
public boolean validateRefreshToken(String token);
@Override
public void invalidateRefreshToken(String refreshToken);
@Override
public boolean shouldRotateRefreshToken(String refreshToken);
@Override
public Authentication getAuthentication(String token);
public TokenParser tokenParser();

// ----- Class: OAuth2TokenValidator -----
public OAuth2TokenValidator(OAuth2ResourceClient resourceClient);
@Override
public boolean validateAccessToken(String token);
@Override
public boolean validateRefreshToken(String token);
@Override
public void invalidateRefreshToken(String refreshToken);
@Override
public Authentication getAuthentication(String token);

// ----- Interface: TokenValidator -----
public boolean validateAccessToken(String token);
public boolean validateRefreshToken(String token);
public void invalidateRefreshToken(String refreshToken);
public Authentication getAuthentication(String token);
default boolean shouldRotateRefreshToken(String refreshToken);
default TokenParser tokenParser();